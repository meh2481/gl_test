diff --git a/CMakeLists.txt b/CMakeLists.txt
index 73ead97..54921d3 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -102,10 +102,3 @@ add_custom_target(clean-all
     COMMAND ${CMAKE_COMMAND} -E remove_directory ${CMAKE_BINARY_DIR}
     COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}
 )
-
-# Vector unit tests
-add_executable(vector_test src/core/VectorTest.cpp src/memory/SmallAllocator.cpp src/memory/LargeMemoryAllocator.cpp)
-target_link_libraries(vector_test ${SDL3_LIBRARIES})
-
-add_executable(largememory_test src/memory/LargeMemoryAllocatorTest.cpp src/memory/LargeMemoryAllocator.cpp src/memory/SmallAllocator.cpp)
-target_link_libraries(largememory_test ${SDL3_LIBRARIES})
\ No newline at end of file
diff --git a/src/core/HashTable.h b/src/core/HashTable.h
index 26baa70..0be4fb0 100644
--- a/src/core/HashTable.h
+++ b/src/core/HashTable.h
@@ -3,6 +3,7 @@
 #include "../memory/MemoryAllocator.h"
 #include <cstdint>
 #include <cassert>
+#include <cstring>
 
 // Hash function for integral types
 template<typename K>
@@ -72,16 +73,18 @@ inline uint32_t hashKey<int>(const int& key) {
 template<typename K, typename V>
 class HashTable {
 public:
-    // Constructor with custom allocator
-    explicit HashTable(MemoryAllocator& allocator)
+    // Constructor with custom allocator and allocation ID
+    explicit HashTable(MemoryAllocator& allocator, const char* callerId)
         : keys_(nullptr)
         , values_(nullptr)
         , occupied_(nullptr)
         , capacity_(0)
         , size_(0)
         , allocator_(&allocator)
+        , callerId_(callerId)
     {
         assert(allocator_ != nullptr);
+        assert(callerId_ != nullptr);
         // Start with a reasonable default capacity
         reserve(16);
     }
@@ -271,9 +274,9 @@ public:
         }
 
         // Allocate new arrays
-        K* newKeys = static_cast<K*>(allocator_->allocate(n * sizeof(K), "HashTable.h:274"));
-        V* newValues = static_cast<V*>(allocator_->allocate(n * sizeof(V), "HashTable.h:275"));
-        bool* newOccupied = static_cast<bool*>(allocator_->allocate(n * sizeof(bool), "HashTable.h:276"));
+        K* newKeys = static_cast<K*>(allocator_->allocate(n * sizeof(K), callerId_));
+        V* newValues = static_cast<V*>(allocator_->allocate(n * sizeof(V), callerId_));
+        bool* newOccupied = static_cast<bool*>(allocator_->allocate(n * sizeof(bool), callerId_));
 
         assert(newKeys != nullptr);
         assert(newValues != nullptr);
@@ -445,4 +448,5 @@ private:
     uint32_t size_;
 
     MemoryAllocator* allocator_;
+    const char* callerId_;
 };
diff --git a/src/core/Vector.h b/src/core/Vector.h
index 7ab10cf..5f9042e 100644
--- a/src/core/Vector.h
+++ b/src/core/Vector.h
@@ -49,6 +49,7 @@ public:
                 capacity_ = 0;
             }
             allocator_ = other.allocator_;
+            callerId_ = other.callerId_;
             reserve(other.size_);
             for (size_t i = 0; i < other.size_; ++i) {
                 new (&data_[i]) T(other.data_[i]);
diff --git a/src/core/VectorTest.cpp b/src/core/VectorTest.cpp
deleted file mode 100644
index 2dae8d1..0000000
--- a/src/core/VectorTest.cpp
+++ /dev/null
@@ -1,815 +0,0 @@
-#include "Vector.h"
-#include "../memory/SmallAllocator.h"
-#include "../memory/LargeMemoryAllocator.h"
-#include <cassert>
-#include <iostream>
-#include <string>
-#include <map>
-#include <unordered_map>
-
-// Helper to track constructions/destructions for testing
-struct TestObject {
-    static int constructCount;
-    static int destructCount;
-    static int copyCount;
-    static int moveCount;
-
-    int value;
-
-    TestObject() : value(0) {
-        ++constructCount;
-    }
-
-    explicit TestObject(int v) : value(v) {
-        ++constructCount;
-    }
-
-    TestObject(const TestObject& other) : value(other.value) {
-        ++constructCount;
-        ++copyCount;
-    }
-
-    TestObject(TestObject&& other) noexcept : value(other.value) {
-        other.value = -1;
-        ++constructCount;
-        ++moveCount;
-    }
-
-    TestObject& operator=(const TestObject& other) {
-        if (this != &other) {
-            value = other.value;
-            ++copyCount;
-        }
-        return *this;
-    }
-
-    TestObject& operator=(TestObject&& other) noexcept {
-        if (this != &other) {
-            value = other.value;
-            other.value = -1;
-            ++moveCount;
-        }
-        return *this;
-    }
-
-    ~TestObject() {
-        ++destructCount;
-    }
-
-    static void reset() {
-        constructCount = 0;
-        destructCount = 0;
-        copyCount = 0;
-        moveCount = 0;
-    }
-};
-
-int TestObject::constructCount = 0;
-int TestObject::destructCount = 0;
-int TestObject::copyCount = 0;
-int TestObject::moveCount = 0;
-
-// Test basic construction and destruction
-void testBasicConstructDestruct() {
-    std::cout << "Testing basic construction and destruction..." << std::endl;
-    SmallAllocator allocator;
-
-    {
-        Vector<int> vec(allocator, "VectorTest.cpp:78:vec");
-        assert(vec.size() == 0);
-        assert(vec.capacity() == 0);
-        assert(vec.empty());
-        assert(&vec.getAllocator() == &allocator);
-    }
-
-    std::cout << "  ✓ Basic construction/destruction passed" << std::endl;
-}
-
-// Test push_back with primitive types
-void testPushBackPrimitive() {
-    std::cout << "Testing push_back with primitive types..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:93:vec");
-    vec.push_back(1);
-    assert(vec.size() == 1);
-    assert(vec[0] == 1);
-
-    vec.push_back(2);
-    assert(vec.size() == 2);
-    assert(vec[0] == 1);
-    assert(vec[1] == 2);
-
-    for (int i = 3; i <= 100; ++i) {
-        vec.push_back(i);
-    }
-    assert(vec.size() == 100);
-    for (int i = 0; i < 100; ++i) {
-        assert(vec[i] == i + 1);
-    }
-
-    std::cout << "  ✓ push_back primitive types passed" << std::endl;
-}
-
-// Test push_back with objects
-void testPushBackObject() {
-    std::cout << "Testing push_back with objects..." << std::endl;
-    SmallAllocator allocator;
-    TestObject::reset();
-
-    {
-        Vector<TestObject> vec(allocator, "VectorTest.cpp:121:vec");
-        vec.push_back(TestObject(42));
-        assert(vec.size() == 1);
-        assert(vec[0].value == 42);
-
-        vec.push_back(TestObject(100));
-        assert(vec.size() == 2);
-        assert(vec[0].value == 42);
-        assert(vec[1].value == 100);
-    }
-
-    assert(TestObject::constructCount == TestObject::destructCount);
-    std::cout << "  ✓ push_back object types passed" << std::endl;
-}
-
-// Test pop_back
-void testPopBack() {
-    std::cout << "Testing pop_back..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:141:vec");
-    vec.push_back(1);
-    vec.push_back(2);
-    vec.push_back(3);
-    assert(vec.size() == 3);
-
-    vec.pop_back();
-    assert(vec.size() == 2);
-    assert(vec[0] == 1);
-    assert(vec[1] == 2);
-
-    vec.pop_back();
-    assert(vec.size() == 1);
-    assert(vec[0] == 1);
-
-    vec.pop_back();
-    assert(vec.size() == 0);
-    assert(vec.empty());
-
-    std::cout << "  ✓ pop_back passed" << std::endl;
-}
-
-// Test operator[]
-void testIndexOperator() {
-    std::cout << "Testing operator[]..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:168:vec");
-    for (int i = 0; i < 10; ++i) {
-        vec.push_back(i * 2);
-    }
-
-    for (int i = 0; i < 10; ++i) {
-        assert(vec[i] == i * 2);
-    }
-
-    vec[5] = 999;
-    assert(vec[5] == 999);
-
-    const Vector<int>& cvec = vec;
-    assert(cvec[5] == 999);
-
-    std::cout << "  ✓ operator[] passed" << std::endl;
-}
-
-// Test at()
-void testAt() {
-    std::cout << "Testing at()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:191:vec");
-    vec.push_back(10);
-    vec.push_back(20);
-
-    assert(vec.at(0) == 10);
-    assert(vec.at(1) == 20);
-
-    vec.at(0) = 100;
-    assert(vec.at(0) == 100);
-
-    const Vector<int>& cvec = vec;
-    assert(cvec.at(0) == 100);
-
-    std::cout << "  ✓ at() passed" << std::endl;
-}
-
-// Test front() and back()
-void testFrontBack() {
-    std::cout << "Testing front() and back()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:212:vec");
-    vec.push_back(1);
-    assert(vec.front() == 1);
-    assert(vec.back() == 1);
-
-    vec.push_back(2);
-    assert(vec.front() == 1);
-    assert(vec.back() == 2);
-
-    vec.push_back(3);
-    assert(vec.front() == 1);
-    assert(vec.back() == 3);
-
-    vec.front() = 100;
-    vec.back() = 200;
-    assert(vec.front() == 100);
-    assert(vec.back() == 200);
-
-    std::cout << "  ✓ front() and back() passed" << std::endl;
-}
-
-// Test data()
-void testData() {
-    std::cout << "Testing data()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:238:vec");
-    vec.push_back(1);
-    vec.push_back(2);
-    vec.push_back(3);
-
-    int* ptr = vec.data();
-    assert(ptr[0] == 1);
-    assert(ptr[1] == 2);
-    assert(ptr[2] == 3);
-
-    ptr[1] = 999;
-    assert(vec[1] == 999);
-
-    const Vector<int>& cvec = vec;
-    const int* cptr = cvec.data();
-    assert(cptr[1] == 999);
-
-    std::cout << "  ✓ data() passed" << std::endl;
-}
-
-// Test clear()
-void testClear() {
-    std::cout << "Testing clear()..." << std::endl;
-    SmallAllocator allocator;
-    TestObject::reset();
-
-    {
-        Vector<TestObject> vec(allocator, "VectorTest.cpp:265:vec");
-        for (int i = 0; i < 10; ++i) {
-            vec.push_back(TestObject(i));
-        }
-        assert(vec.size() == 10);
-
-        size_t oldCapacity = vec.capacity();
-        vec.clear();
-        assert(vec.size() == 0);
-        assert(vec.empty());
-        assert(vec.capacity() == oldCapacity);
-    }
-
-    assert(TestObject::constructCount == TestObject::destructCount);
-    std::cout << "  ✓ clear() passed" << std::endl;
-}
-
-// Test reserve()
-void testReserve() {
-    std::cout << "Testing reserve()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:287:vec");
-    assert(vec.capacity() == 0);
-
-    vec.reserve(10);
-    assert(vec.capacity() >= 10);
-    assert(vec.size() == 0);
-
-    vec.push_back(1);
-    vec.push_back(2);
-    assert(vec.size() == 2);
-    assert(vec.capacity() >= 10);
-
-    vec.reserve(5);
-    assert(vec.capacity() >= 10);
-
-    vec.reserve(100);
-    assert(vec.capacity() >= 100);
-    assert(vec.size() == 2);
-    assert(vec[0] == 1);
-    assert(vec[1] == 2);
-
-    std::cout << "  ✓ reserve() passed" << std::endl;
-}
-
-// Test resize()
-void testResize() {
-    std::cout << "Testing resize()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:316:vec");
-    vec.resize(5);
-    assert(vec.size() == 5);
-    for (size_t i = 0; i < vec.size(); ++i) {
-        assert(vec[i] == 0);
-    }
-
-    vec.resize(10, 42);
-    assert(vec.size() == 10);
-    for (size_t i = 0; i < 5; ++i) {
-        assert(vec[i] == 0);
-    }
-    for (size_t i = 5; i < 10; ++i) {
-        assert(vec[i] == 42);
-    }
-
-    vec.resize(3);
-    assert(vec.size() == 3);
-    for (size_t i = 0; i < 3; ++i) {
-        assert(vec[i] == 0);
-    }
-
-    std::cout << "  ✓ resize() passed" << std::endl;
-}
-
-// Test shrink_to_fit()
-void testShrinkToFit() {
-    std::cout << "Testing shrink_to_fit()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:346:vec");
-    vec.reserve(100);
-    vec.push_back(1);
-    vec.push_back(2);
-    assert(vec.capacity() >= 100);
-    assert(vec.size() == 2);
-
-    vec.shrink_to_fit();
-    assert(vec.capacity() == vec.size());
-    assert(vec[0] == 1);
-    assert(vec[1] == 2);
-
-    vec.clear();
-    vec.shrink_to_fit();
-    assert(vec.capacity() == 0);
-
-    std::cout << "  ✓ shrink_to_fit() passed" << std::endl;
-}
-
-// Test erase()
-void testErase() {
-    std::cout << "Testing erase()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:370:vec");
-    for (int i = 0; i < 5; ++i) {
-        vec.push_back(i);
-    }
-
-    vec.erase(2);
-    assert(vec.size() == 4);
-    assert(vec[0] == 0);
-    assert(vec[1] == 1);
-    assert(vec[2] == 3);
-    assert(vec[3] == 4);
-
-    vec.erase(0);
-    assert(vec.size() == 3);
-    assert(vec[0] == 1);
-    assert(vec[1] == 3);
-    assert(vec[2] == 4);
-
-    vec.erase(2);
-    assert(vec.size() == 2);
-    assert(vec[0] == 1);
-    assert(vec[1] == 3);
-
-    std::cout << "  ✓ erase() passed" << std::endl;
-}
-
-// Test insert()
-void testInsert() {
-    std::cout << "Testing insert()..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:401:vec");
-    vec.insert(0, 10);
-    assert(vec.size() == 1);
-    assert(vec[0] == 10);
-
-    vec.insert(0, 5);
-    assert(vec.size() == 2);
-    assert(vec[0] == 5);
-    assert(vec[1] == 10);
-
-    vec.insert(2, 15);
-    assert(vec.size() == 3);
-    assert(vec[0] == 5);
-    assert(vec[1] == 10);
-    assert(vec[2] == 15);
-
-    vec.insert(1, 7);
-    assert(vec.size() == 4);
-    assert(vec[0] == 5);
-    assert(vec[1] == 7);
-    assert(vec[2] == 10);
-    assert(vec[3] == 15);
-
-    std::cout << "  ✓ insert() passed" << std::endl;
-}
-
-// Test iterators
-void testIterators() {
-    std::cout << "Testing iterators..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:432:vec");
-    for (int i = 0; i < 5; ++i) {
-        vec.push_back(i);
-    }
-
-    int sum = 0;
-    for (int* it = vec.begin(); it != vec.end(); ++it) {
-        sum += *it;
-    }
-    assert(sum == 10);
-
-    const Vector<int>& cvec = vec;
-    sum = 0;
-    for (const int* it = cvec.begin(); it != cvec.end(); ++it) {
-        sum += *it;
-    }
-    assert(sum == 10);
-
-    std::cout << "  ✓ iterators passed" << std::endl;
-}
-
-// Test copy constructor
-void testCopyConstructor() {
-    std::cout << "Testing copy constructor..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec1(allocator, "VectorTest.cpp:458:vec1");
-    for (int i = 0; i < 10; ++i) {
-        vec1.push_back(i);
-    }
-
-    Vector<int> vec2(vec1);
-    assert(vec2.size() == vec1.size());
-    for (size_t i = 0; i < vec1.size(); ++i) {
-        assert(vec2[i] == vec1[i]);
-    }
-
-    vec1[0] = 999;
-    assert(vec2[0] == 0);
-
-    std::cout << "  ✓ copy constructor passed" << std::endl;
-}
-
-// Test copy assignment
-void testCopyAssignment() {
-    std::cout << "Testing copy assignment..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec1(allocator, "VectorTest.cpp:480:vec1");
-    for (int i = 0; i < 10; ++i) {
-        vec1.push_back(i);
-    }
-
-    Vector<int> vec2(allocator, "VectorTest.cpp:485:vec2");
-    vec2.push_back(999);
-    vec2 = vec1;
-
-    assert(vec2.size() == vec1.size());
-    for (size_t i = 0; i < vec1.size(); ++i) {
-        assert(vec2[i] == vec1[i]);
-    }
-
-    vec1[0] = 777;
-    assert(vec2[0] == 0);
-
-    vec1 = vec1;
-    assert(vec1[0] == 777);
-
-    std::cout << "  ✓ copy assignment passed" << std::endl;
-}
-
-// Test move constructor
-void testMoveConstructor() {
-    std::cout << "Testing move constructor..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec1(allocator, "VectorTest.cpp:508:vec1");
-    for (int i = 0; i < 10; ++i) {
-        vec1.push_back(i);
-    }
-    int* oldData = vec1.data();
-    size_t oldSize = vec1.size();
-    size_t oldCapacity = vec1.capacity();
-
-    Vector<int> vec2(std::move(vec1));
-    assert(vec2.size() == oldSize);
-    assert(vec2.capacity() == oldCapacity);
-    assert(vec2.data() == oldData);
-
-    assert(vec1.size() == 0);
-    assert(vec1.capacity() == 0);
-    assert(vec1.data() == nullptr);
-
-    for (int i = 0; i < 10; ++i) {
-        assert(vec2[i] == i);
-    }
-
-    std::cout << "  ✓ move constructor passed" << std::endl;
-}
-
-// Test move assignment
-void testMoveAssignment() {
-    std::cout << "Testing move assignment..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec1(allocator, "VectorTest.cpp:537:vec1");
-    for (int i = 0; i < 10; ++i) {
-        vec1.push_back(i);
-    }
-    int* oldData = vec1.data();
-    size_t oldSize = vec1.size();
-    size_t oldCapacity = vec1.capacity();
-
-    Vector<int> vec2(allocator, "VectorTest.cpp:545:vec2");
-    vec2.push_back(999);
-    vec2 = std::move(vec1);
-
-    assert(vec2.size() == oldSize);
-    assert(vec2.capacity() == oldCapacity);
-    assert(vec2.data() == oldData);
-
-    assert(vec1.size() == 0);
-    assert(vec1.capacity() == 0);
-    assert(vec1.data() == nullptr);
-
-    for (int i = 0; i < 10; ++i) {
-        assert(vec2[i] == i);
-    }
-
-    vec2 = std::move(vec2);
-    assert(vec2.size() == 10);
-
-    std::cout << "  ✓ move assignment passed" << std::endl;
-}
-
-// Test with std::map (critical for the segfault fix)
-void testWithStdMap() {
-    std::cout << "Testing with std::map..." << std::endl;
-    SmallAllocator allocator;
-
-    {
-        std::map<int, Vector<int>> map;
-        Vector<int> vec(allocator, "VectorTest.cpp:574:vec");
-        vec.push_back(1);
-        vec.push_back(2);
-        vec.push_back(3);
-
-        map.insert(std::make_pair(1, std::move(vec)));
-        auto it = map.find(1);
-        assert(it != map.end());
-        assert(it->second.size() == 3);
-        assert(it->second[0] == 1);
-
-        Vector<int> vec2(allocator, "VectorTest.cpp:585:vec2");
-        vec2.push_back(10);
-        vec2.push_back(20);
-        map.insert(std::make_pair(2, std::move(vec2)));
-        it = map.find(2);
-        assert(it != map.end());
-        assert(it->second.size() == 2);
-        assert(it->second[0] == 10);
-
-        map.erase(1);
-        assert(map.find(1) == map.end());
-        it = map.find(2);
-        assert(it != map.end());
-        assert(it->second.size() == 2);
-    }
-
-    std::cout << "  ✓ std::map integration passed" << std::endl;
-}
-
-// Test with std::unordered_map
-void testWithStdUnorderedMap() {
-    std::cout << "Testing with std::unordered_map..." << std::endl;
-    SmallAllocator allocator;
-
-    {
-        std::unordered_map<int, Vector<int>> map;
-        Vector<int> vec(allocator, "VectorTest.cpp:611:vec");
-        vec.push_back(1);
-        vec.push_back(2);
-
-        map.insert(std::make_pair(1, std::move(vec)));
-        auto it = map.find(1);
-        assert(it != map.end());
-        assert(it->second.size() == 2);
-
-        Vector<int> vec2(allocator, "VectorTest.cpp:620:vec2");
-        vec2.push_back(10);
-        map.insert(std::make_pair(2, std::move(vec2)));
-        it = map.find(2);
-        assert(it != map.end());
-        assert(it->second.size() == 1);
-
-        map.clear();
-    }
-
-    std::cout << "  ✓ std::unordered_map integration passed" << std::endl;
-}
-
-// Test nested vectors
-void testNestedVectors() {
-    std::cout << "Testing nested vectors..." << std::endl;
-    SmallAllocator allocator;
-
-    {
-        Vector<Vector<int>> outer(allocator, "VectorTest.cpp:639:outer");
-
-        Vector<int> inner1(allocator, "VectorTest.cpp:641:inner1");
-        inner1.push_back(1);
-        inner1.push_back(2);
-        outer.push_back(std::move(inner1));
-
-        Vector<int> inner2(allocator, "VectorTest.cpp:646:inner2");
-        inner2.push_back(10);
-        inner2.push_back(20);
-        inner2.push_back(30);
-        outer.push_back(std::move(inner2));
-
-        assert(outer.size() == 2);
-        assert(outer[0].size() == 2);
-        assert(outer[1].size() == 3);
-        assert(outer[0][0] == 1);
-        assert(outer[1][2] == 30);
-    }
-
-    std::cout << "  ✓ nested vectors passed" << std::endl;
-}
-
-// Test capacity growth
-void testCapacityGrowth() {
-    std::cout << "Testing capacity growth..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:667:vec");
-    assert(vec.capacity() == 0);
-
-    vec.push_back(1);
-    assert(vec.capacity() >= 1);
-    size_t cap1 = vec.capacity();
-
-    for (int i = 0; i < 100; ++i) {
-        vec.push_back(i);
-    }
-
-    assert(vec.capacity() > cap1);
-    assert(vec.capacity() >= vec.size());
-
-    std::cout << "  ✓ capacity growth passed" << std::endl;
-}
-
-#define VEC_ITEMS 100
-
-// Test with large allocator
-void testWithLargeAllocator() {
-    std::cout << "Testing with LargeMemoryAllocator..." << std::endl;
-    LargeMemoryAllocator allocator;
-
-    {
-        Vector<int> vec(allocator, "VectorTest.cpp:692:vec");
-        for (int i = 0; i < VEC_ITEMS; ++i) {
-            vec.push_back(i);
-        }
-        assert(vec.size() == VEC_ITEMS);
-        for (int i = 0; i < VEC_ITEMS; ++i) {
-            assert(vec[i] == i);
-        }
-    }
-
-    std::cout << "  ✓ LargeMemoryAllocator integration passed" << std::endl;
-}
-
-// Test empty vector operations
-void testEmptyVector() {
-    std::cout << "Testing empty vector operations..." << std::endl;
-    SmallAllocator allocator;
-
-    Vector<int> vec(allocator, "VectorTest.cpp:710:vec");
-    assert(vec.empty());
-    assert(vec.size() == 0);
-    assert(vec.capacity() == 0);
-    assert(vec.data() == nullptr || vec.size() == 0);
-
-    vec.clear();
-    assert(vec.empty());
-
-    vec.resize(0);
-    assert(vec.empty());
-
-    vec.shrink_to_fit();
-    assert(vec.empty());
-
-    std::cout << "  ✓ empty vector operations passed" << std::endl;
-}
-
-// Test object lifecycle
-void testObjectLifecycle() {
-    std::cout << "Testing object lifecycle..." << std::endl;
-    SmallAllocator allocator;
-    TestObject::reset();
-
-    {
-        Vector<TestObject> vec(allocator, "VectorTest.cpp:735:vec");
-        vec.push_back(TestObject(1));
-        vec.push_back(TestObject(2));
-        vec.push_back(TestObject(3));
-
-        vec.resize(10);
-        vec.resize(5);
-        vec.clear();
-
-        vec.push_back(TestObject(100));
-    }
-
-    assert(TestObject::constructCount == TestObject::destructCount);
-    std::cout << "  ✓ object lifecycle passed (constructs: " << TestObject::constructCount
-              << ", destructs: " << TestObject::destructCount << ")" << std::endl;
-}
-
-// Test getAllocator
-void testGetAllocator() {
-    std::cout << "Testing getAllocator()..." << std::endl;
-    SmallAllocator allocator1;
-    SmallAllocator allocator2;
-
-    Vector<int> vec1(allocator1, "VectorTest.cpp:758:vec1");
-    Vector<int> vec2(allocator2, "VectorTest.cpp:759:vec2");
-
-    assert(&vec1.getAllocator() == &allocator1);
-    assert(&vec2.getAllocator() == &allocator2);
-    assert(&vec1.getAllocator() != &vec2.getAllocator());
-
-    std::cout << "  ✓ getAllocator() passed" << std::endl;
-}
-
-// Main test runner
-int main() {
-    std::cout << "\n========================================" << std::endl;
-    std::cout << "Running Vector class unit tests" << std::endl;
-    std::cout << "========================================\n" << std::endl;
-
-    try {
-        testBasicConstructDestruct();
-        testPushBackPrimitive();
-        testPushBackObject();
-        testPopBack();
-        testIndexOperator();
-        testAt();
-        testFrontBack();
-        testData();
-        testClear();
-        testReserve();
-        testResize();
-        testShrinkToFit();
-        testErase();
-        testInsert();
-        testIterators();
-        testCopyConstructor();
-        testCopyAssignment();
-        testMoveConstructor();
-        testMoveAssignment();
-        testWithStdMap();
-        testWithStdUnorderedMap();
-        testNestedVectors();
-        testCapacityGrowth();
-        testWithLargeAllocator();
-        testEmptyVector();
-        testObjectLifecycle();
-        testGetAllocator();
-
-        std::cout << "\n========================================" << std::endl;
-        std::cout << "All tests passed! ✓" << std::endl;
-        std::cout << "========================================\n" << std::endl;
-
-        return 0;
-    } catch (const std::exception& e) {
-        std::cerr << "\n✗ Test failed with exception: " << e.what() << std::endl;
-        return 1;
-    } catch (...) {
-        std::cerr << "\n✗ Test failed with unknown exception" << std::endl;
-        return 1;
-    }
-}
diff --git a/src/debug/ImGuiManager.cpp b/src/debug/ImGuiManager.cpp
index d549646..8e2223b 100644
--- a/src/debug/ImGuiManager.cpp
+++ b/src/debug/ImGuiManager.cpp
@@ -19,7 +19,13 @@ static void check_vk_result(VkResult err) {
     assert(err == VK_SUCCESS);
 }
 
-ImGuiManager::ImGuiManager(MemoryAllocator* allocator, ConsoleBuffer* consoleBuffer) : initialized_(false), device_(VK_NULL_HANDLE), imguiPool_(VK_NULL_HANDLE), stringAllocator_(allocator), consoleBuffer_(consoleBuffer) {
+ImGuiManager::ImGuiManager(MemoryAllocator* allocator, ConsoleBuffer* consoleBuffer)
+    : initialized_(false)
+    , device_(VK_NULL_HANDLE)
+    , imguiPool_(VK_NULL_HANDLE)
+    , imguiTextureCache_(*allocator, "ImGuiManager::imguiTextureCache_")
+    , stringAllocator_(allocator)
+    , consoleBuffer_(consoleBuffer) {
     assert(stringAllocator_ != nullptr);
     assert(consoleBuffer_ != nullptr);
     std::cout << "ImGuiManager: Using shared memory allocator" << std::endl;
@@ -812,14 +818,14 @@ void ImGuiManager::showTextureSelector(PakResource* pakResource, VulkanRenderer*
             VkSampler sampler;
             if (renderer->getTextureForImGui(lookupTexId, &imageView, &sampler)) {
                 // Check if we already have an ImGui descriptor for this texture
-                auto it = imguiTextureCache_.find(lookupTexId);
+                VkDescriptorSet* descSetPtr = imguiTextureCache_.find(lookupTexId);
                 VkDescriptorSet imguiTexture;
-                if (it != imguiTextureCache_.end()) {
-                    imguiTexture = it->second;
+                if (descSetPtr != nullptr) {
+                    imguiTexture = *descSetPtr;
                 } else {
                     // Create a new ImGui texture descriptor
                     imguiTexture = ImGui_ImplVulkan_AddTexture(sampler, imageView, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
-                    imguiTextureCache_[lookupTexId] = imguiTexture;
+                    imguiTextureCache_.insert(lookupTexId, imguiTexture);
                 }
 
                 // Show texture preview as a clickable image button
@@ -1682,32 +1688,6 @@ void ImGuiManager::showMemoryAllocatorWindow(MemoryAllocator* smallAllocator, Me
 
                     ImGui::Dummy(ImVec2(width, height));
 
-                    // Check for hover and show tooltip with allocationId
-                    if (ImGui::IsItemHovered()) {
-                        ImVec2 mousePos = ImGui::GetMousePos();
-                        float relativeX = mousePos.x - pos.x;
-                        if (relativeX >= 0 && relativeX <= width) {
-                            for (size_t j = 0; j < poolInfo[i].blockCount; j++) {
-                                SmallAllocator::BlockInfo& block = poolInfo[i].blocks[j];
-                                float blockStart = (float)block.offset / poolInfo[i].capacity * width;
-                                float blockSize = (float)(block.size + SmallAllocator::getBlockHeaderSize()) / poolInfo[i].capacity * width;
-
-                                if (relativeX >= blockStart && relativeX < blockStart + blockSize) {
-                                    ImGui::BeginTooltip();
-                                    if (!block.isFree && block.allocationId && block.allocationId[0] != '\0') {
-                                        ImGui::Text("Allocation ID: %s", block.allocationId);
-                                    } else {
-                                        ImGui::Text("Allocation ID: (none)");
-                                    }
-                                    ImGui::Text("Size: %zu bytes", block.size);
-                                    ImGui::Text("Status: %s", block.isFree ? "Free" : "Used");
-                                    ImGui::EndTooltip();
-                                    break;
-                                }
-                            }
-                        }
-                    }
-
                     // Legend
                     ImGui::TextColored(ImVec4(0.2f, 0.78f, 0.2f, 1.0f), "Green = Free");
                     ImGui::SameLine();
@@ -1803,32 +1783,6 @@ void ImGuiManager::showMemoryAllocatorWindow(MemoryAllocator* smallAllocator, Me
 
                     ImGui::Dummy(ImVec2(width, height));
 
-                    // Check for hover and show tooltip with allocationId
-                    if (ImGui::IsItemHovered()) {
-                        ImVec2 mousePos = ImGui::GetMousePos();
-                        float relativeX = mousePos.x - pos.x;
-                        if (relativeX >= 0 && relativeX <= width) {
-                            for (size_t j = 0; j < chunkInfo[i].blockCount; j++) {
-                                LargeMemoryAllocator::BlockInfo& block = chunkInfo[i].blocks[j];
-                                float blockStart = (float)block.offset / chunkInfo[i].size * width;
-                                float blockSize = (float)(block.size + LargeMemoryAllocator::getBlockHeaderSize()) / chunkInfo[i].size * width;
-
-                                if (relativeX >= blockStart && relativeX < blockStart + blockSize) {
-                                    ImGui::BeginTooltip();
-                                    if (!block.isFree && block.allocationId && block.allocationId[0] != '\0') {
-                                        ImGui::Text("Allocation ID: %s", block.allocationId);
-                                    } else {
-                                        ImGui::Text("Allocation ID: (none)");
-                                    }
-                                    ImGui::Text("Size: %zu bytes", block.size);
-                                    ImGui::Text("Status: %s", block.isFree ? "Free" : "Used");
-                                    ImGui::EndTooltip();
-                                    break;
-                                }
-                            }
-                        }
-                    }
-
                     // Legend
                     ImGui::TextColored(ImVec4(0.2f, 0.78f, 0.2f, 1.0f), "Green = Free");
                     ImGui::SameLine();
diff --git a/src/debug/ImGuiManager.h b/src/debug/ImGuiManager.h
index 333d189..55427e4 100644
--- a/src/debug/ImGuiManager.h
+++ b/src/debug/ImGuiManager.h
@@ -9,11 +9,11 @@
 #include <imgui_impl_vulkan.h>
 #include "../effects/ParticleSystem.h"
 #include "../core/String.h"
+#include "../core/HashTable.h"
 #include "../memory/MemoryAllocator.h"
 #include "../memory/SmallAllocator.h"
 #include "../memory/LargeMemoryAllocator.h"
 #include <cstdint>
-#include <map>
 
 // Forward declarations
 class VulkanRenderer;
@@ -182,7 +182,7 @@ private:
     String truncateTextureName(const char* fullName, float maxWidth);
 
     // ImGui texture cache for preview images
-    std::map<uint64_t, VkDescriptorSet> imguiTextureCache_;
+    HashTable<uint64_t, VkDescriptorSet> imguiTextureCache_;
 };
 
 #endif // DEBUG
diff --git a/src/memory/LargeMemoryAllocator.cpp b/src/memory/LargeMemoryAllocator.cpp
index 8ebec80..bc5c6f2 100644
--- a/src/memory/LargeMemoryAllocator.cpp
+++ b/src/memory/LargeMemoryAllocator.cpp
@@ -430,7 +430,6 @@ LargeMemoryAllocator::ChunkInfo* LargeMemoryAllocator::getChunkInfo(size_t* outC
             chunkInfo[i].blocks[j].offset = (char*)block - chunk->memory;
             chunkInfo[i].blocks[j].size = block->size;
             chunkInfo[i].blocks[j].isFree = block->isFree;
-            chunkInfo[i].blocks[j].allocationId = block->allocationId;
 
             BlockHeader* nextBlock = (BlockHeader*)((char*)block + sizeof(BlockHeader) + block->size);
             if ((char*)nextBlock >= chunkEnd) {
diff --git a/src/memory/LargeMemoryAllocator.h b/src/memory/LargeMemoryAllocator.h
index 970840f..7115376 100644
--- a/src/memory/LargeMemoryAllocator.h
+++ b/src/memory/LargeMemoryAllocator.h
@@ -25,7 +25,6 @@ public:
         size_t offset;      // Offset from chunk start
         size_t size;        // Size of block
         bool isFree;        // Is this block free?
-        const char* allocationId; // Identifier for tracking allocation source
     };
 
     struct ChunkInfo {
diff --git a/src/memory/LargeMemoryAllocatorTest.cpp b/src/memory/LargeMemoryAllocatorTest.cpp
deleted file mode 100644
index a4b857d..0000000
--- a/src/memory/LargeMemoryAllocatorTest.cpp
+++ /dev/null
@@ -1,536 +0,0 @@
-#include "LargeMemoryAllocator.h"
-#include <iostream>
-#include <cassert>
-#include <cstring>
-#include <vector>
-
-// Test result tracking
-static int testsRun = 0;
-static int testsPassed = 0;
-static int testsFailed = 0;
-
-#define TEST(name) \
-    std::cout << "\nTesting " << name << "..." << std::endl; \
-    testsRun++;
-
-#define PASS() \
-    do { \
-        std::cout << "  ✓ " << __func__ << " passed" << std::endl; \
-        testsPassed++; \
-    } while(0)
-
-#define FAIL(msg) \
-    do { \
-        std::cerr << "  ✗ " << __func__ << " FAILED: " << msg << std::endl; \
-        testsFailed++; \
-    } while(0)
-
-#define EXPECT_TIMEOUT(name, timeout_sec) \
-    std::cout << "  ⚠ " << name << " expected to timeout (infinite loop bug)" << std::endl; \
-    testsFailed++;
-
-// Basic allocation and deallocation
-void testBasicAllocation() {
-    TEST("basic allocation");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:37");
-    assert(ptr != nullptr);
-
-    size_t usedBefore = allocator.getUsedMemory();
-    assert(usedBefore > 0);
-
-    allocator.free(ptr);
-
-    size_t usedAfter = allocator.getUsedMemory();
-    assert(usedAfter < usedBefore);
-
-    PASS();
-}
-
-// Multiple allocations
-void testMultipleAllocations() {
-    TEST("multiple allocations");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr1 = allocator.allocate(64, "LargeMemoryAllocatorTest.cpp:56");
-    void* ptr2 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:57");
-    void* ptr3 = allocator.allocate(256, "LargeMemoryAllocatorTest.cpp:58");
-
-    assert(ptr1 != nullptr);
-    assert(ptr2 != nullptr);
-    assert(ptr3 != nullptr);
-    assert(ptr1 != ptr2);
-    assert(ptr2 != ptr3);
-    assert(ptr1 != ptr3);
-
-    allocator.free(ptr1);
-    allocator.free(ptr2);
-    allocator.free(ptr3);
-
-    PASS();
-}
-
-// Free in different order
-void testFreeDifferentOrder() {
-    TEST("free in different order");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr1 = allocator.allocate(64, "LargeMemoryAllocatorTest.cpp:79");
-    void* ptr2 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:80");
-    void* ptr3 = allocator.allocate(256, "LargeMemoryAllocatorTest.cpp:81");
-
-    // Free in reverse order
-    allocator.free(ptr3);
-    allocator.free(ptr2);
-    allocator.free(ptr1);
-
-    PASS();
-}
-
-// Reuse freed memory
-void testReuseFreedMemory() {
-    TEST("reuse freed memory");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr1 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:96");
-    allocator.free(ptr1);
-
-    void* ptr2 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:99");
-    assert(ptr2 != nullptr);
-    // ptr2 might or might not be the same as ptr1 depending on implementation
-
-    allocator.free(ptr2);
-
-    PASS();
-}
-
-// Large allocation requiring new chunk
-void testLargeAllocation() {
-    TEST("large allocation requiring new chunk");
-    LargeMemoryAllocator allocator(1024); // Small initial chunk
-
-    size_t totalBefore = allocator.getTotalMemory();
-
-    void* ptr = allocator.allocate(2048, "LargeMemoryAllocatorTest.cpp:115"); // Larger than initial chunk
-    assert(ptr != nullptr);
-
-    size_t totalAfter = allocator.getTotalMemory();
-    assert(totalAfter > totalBefore); // Should have added a new chunk
-
-    allocator.free(ptr);
-
-    PASS();
-}
-
-// Block splitting
-void testBlockSplitting() {
-    TEST("block splitting");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    // Allocate small amount from large block
-    void* ptr1 = allocator.allocate(64, "LargeMemoryAllocatorTest.cpp:132");
-    assert(ptr1 != nullptr);
-
-    // Should still have plenty of free space
-    void* ptr2 = allocator.allocate(64, "LargeMemoryAllocatorTest.cpp:136");
-    assert(ptr2 != nullptr);
-
-    allocator.free(ptr1);
-    allocator.free(ptr2);
-
-    PASS();
-}
-
-// Adjacent block merging
-void testAdjacentBlockMerging() {
-    TEST("adjacent block merging");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr1 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:150");
-    void* ptr2 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:151");
-    void* ptr3 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:152");
-
-    size_t usedBefore = allocator.getUsedMemory();
-
-    // Free middle block
-    allocator.free(ptr2);
-
-    // Free adjacent blocks - should trigger merging
-    allocator.free(ptr1);
-    allocator.free(ptr3);
-
-    size_t usedAfter = allocator.getUsedMemory();
-    assert(usedAfter < usedBefore);
-
-    PASS();
-}
-
-// Defragmentation
-void testDefragmentation() {
-    TEST("defragmentation");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    void* ptr1 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:174");
-    void* ptr2 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:175");
-    void* ptr3 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:176");
-
-    allocator.free(ptr1);
-    allocator.free(ptr3);
-
-    size_t mergedBlocks = allocator.defragment();
-    std::cout << "  Merged " << mergedBlocks << " blocks" << std::endl;
-
-    allocator.free(ptr2);
-
-    PASS();
-}
-
-// Memory usage tracking
-void testMemoryUsageTracking() {
-    TEST("memory usage tracking");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    size_t total = allocator.getTotalMemory();
-    size_t used = allocator.getUsedMemory();
-    size_t free = allocator.getFreeMemory();
-
-    assert(total > 0);
-    assert(used >= 0);
-    assert(free > 0);
-    assert(used + free <= total); // Account for headers
-
-    void* ptr = allocator.allocate(1024, "LargeMemoryAllocatorTest.cpp:203");
-    size_t usedAfter = allocator.getUsedMemory();
-    assert(usedAfter > used);
-
-    allocator.free(ptr);
-
-    PASS();
-}
-
-// Alignment verification
-void testAlignment() {
-    TEST("alignment");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    // LargeMemoryAllocator should provide 16-byte alignment
-    // BlockHeader is now aligned to 16 bytes using alignas(16)
-
-    // Allocate various sizes
-    for (size_t size = 1; size <= 256; size *= 2) {
-        void* ptr = allocator.allocate(size, "LargeMemoryAllocatorTest.cpp:222");
-        assert(ptr != nullptr);
-
-        // Check alignment
-        uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
-        std::cout << "  Size " << size << " -> address " << ptr
-                  << " (%" << (addr % 16 == 0 ? "16" : "8") << ")" << std::endl;
-
-        // Should be 16-byte aligned
-        assert((addr % 16) == 0);
-
-        allocator.free(ptr);
-    }
-
-    PASS();
-}
-
-// Stress test with many small allocations
-void testManySmallAllocations() {
-    TEST("many small allocations");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    const int count = 30; // Keep below 32 to avoid infinite loop bug
-    std::vector<void*> ptrs;
-
-    for (int i = 0; i < count; ++i) {
-        void* ptr = allocator.allocate(32, "LargeMemoryAllocatorTest.cpp:248");
-        assert(ptr != nullptr);
-        ptrs.push_back(ptr);
-    }
-
-    for (void* ptr : ptrs) {
-        allocator.free(ptr);
-    }
-
-    PASS();
-}
-
-// Test that previously demonstrated the infinite loop bug with 32+ allocations
-void testInfiniteLoopBugWith32PlusAllocations() {
-    TEST("32+ allocations (previously triggered infinite loop bug)");
-
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    const int count = 100; // This previously triggered the bug
-    std::vector<void*> ptrs;
-
-    for (int i = 0; i < count; ++i) {
-        void* ptr = allocator.allocate(32, "LargeMemoryAllocatorTest.cpp:270");
-        assert(ptr != nullptr);
-        ptrs.push_back(ptr);
-    }
-
-    for (void* ptr : ptrs) {
-        allocator.free(ptr);
-    }
-
-    PASS();
-}
-
-// Test chunk removal threshold
-void testChunkRemovalThreshold() {
-    TEST("chunk removal when usage drops below threshold");
-    LargeMemoryAllocator allocator(1024); // Small chunks
-
-    // Allocate enough to trigger new chunk
-    void* large = allocator.allocate(2048, "LargeMemoryAllocatorTest.cpp:288");
-    assert(large != nullptr);
-
-    size_t totalBefore = allocator.getTotalMemory();
-
-    // Free it - should trigger chunk removal if usage < 25%
-    allocator.free(large);
-
-    size_t totalAfter = allocator.getTotalMemory();
-    // Chunks might or might not be removed depending on usage
-    std::cout << "  Total before: " << totalBefore << ", after: " << totalAfter << std::endl;
-
-    PASS();
-}
-
-// Test writing to allocated memory
-void testMemoryReadWrite() {
-    TEST("memory read/write");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    size_t size = 128;
-    char* ptr = static_cast<char*>(allocator.allocate(size, "LargeMemoryAllocatorTest.cpp:309"));
-    assert(ptr != nullptr);
-
-    // Write pattern
-    for (size_t i = 0; i < size; ++i) {
-        ptr[i] = static_cast<char>(i % 256);
-    }
-
-    // Read and verify pattern
-    for (size_t i = 0; i < size; ++i) {
-        assert(ptr[i] == static_cast<char>(i % 256));
-    }
-
-    allocator.free(ptr);
-
-    PASS();
-}
-
-// Test zero-sized allocation (should assert/fail)
-void testZeroSizedAllocation() {
-    TEST("zero-sized allocation (should assert)");
-
-    std::cout << "  Note: Skipping zero-size test as it would trigger assertion" << std::endl;
-    PASS();
-
-    /* This would assert:
-    LargeMemoryAllocator allocator(1024 * 1024);
-    void* ptr = allocator.allocate(0, "LargeMemoryAllocatorTest.cpp:336");
-    */
-}
-
-// Test double free detection (should assert/fail)
-void testDoubleFree() {
-    TEST("double free detection (should assert)");
-
-    std::cout << "  Note: Skipping double-free test as it would trigger assertion" << std::endl;
-    PASS();
-
-    /* This would assert:
-    LargeMemoryAllocator allocator(1024 * 1024);
-    void* ptr = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:349");
-    allocator.free(ptr);
-    allocator.free(ptr); // Double free - should assert
-    */
-}
-
-// Test growing allocations
-void testGrowingAllocations() {
-    TEST("growing allocations");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    std::vector<void*> ptrs;
-
-    // Allocate progressively larger blocks
-    for (size_t size = 16; size <= 512; size *= 2) {
-        void* ptr = allocator.allocate(size, "LargeMemoryAllocatorTest.cpp:364");
-        assert(ptr != nullptr);
-        ptrs.push_back(ptr);
-    }
-
-    // Free all
-    for (void* ptr : ptrs) {
-        allocator.free(ptr);
-    }
-
-    PASS();
-}
-
-// Test fragmentation scenario
-void testFragmentation() {
-    TEST("fragmentation scenario");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    std::vector<void*> ptrs;
-
-    // Allocate many blocks
-    for (int i = 0; i < 20; ++i) {
-        ptrs.push_back(allocator.allocate(64, "LargeMemoryAllocatorTest.cpp:386"));
-    }
-
-    // Free every other block
-    for (size_t i = 0; i < ptrs.size(); i += 2) {
-        allocator.free(ptrs[i]);
-        ptrs[i] = nullptr;
-    }
-
-    // Try to allocate large block - might fail due to fragmentation
-    void* large = allocator.allocate(512, "LargeMemoryAllocatorTest.cpp:396");
-    if (large) {
-        allocator.free(large);
-    }
-
-    // Free remaining blocks
-    for (void* ptr : ptrs) {
-        if (ptr) {
-            allocator.free(ptr);
-        }
-    }
-
-    PASS();
-}
-
-// Test the specific sequence that previously triggered the bug
-void testBugTriggeringSequence() {
-    TEST("bug-triggering sequence (growth from 32 to 64 capacity)");
-
-    LargeMemoryAllocator allocator(1024 * 1024);
-    std::vector<void*> ptrs;
-
-    // Allocate 32 items
-    for (int i = 0; i < 32; ++i) {
-        ptrs.push_back(allocator.allocate(32, "LargeMemoryAllocatorTest.cpp:420"));
-    }
-
-    // Allocate 33rd item - previously triggered infinite loop during realloc
-    ptrs.push_back(allocator.allocate(32, "LargeMemoryAllocatorTest.cpp:424"));
-
-    // Free all
-    for (void* ptr : ptrs) {
-        allocator.free(ptr);
-    }
-
-    PASS();
-}
-
-// Test best-fit allocation strategy
-void testBestFitStrategy() {
-    TEST("best-fit allocation strategy");
-    LargeMemoryAllocator allocator(1024 * 1024);
-
-    // Create holes of different sizes
-    void* ptr1 = allocator.allocate(128, "LargeMemoryAllocatorTest.cpp:440");
-    void* ptr2 = allocator.allocate(256, "LargeMemoryAllocatorTest.cpp:441");
-    void* ptr3 = allocator.allocate(512, "LargeMemoryAllocatorTest.cpp:442");
-
-    allocator.free(ptr1); // 128-byte hole
-    allocator.free(ptr3); // 512-byte hole
-
-    // Allocate 100 bytes - should use best fit (128-byte hole)
-    void* ptr4 = allocator.allocate(100, "LargeMemoryAllocatorTest.cpp:448");
-    assert(ptr4 != nullptr);
-
-    allocator.free(ptr2);
-    allocator.free(ptr4);
-
-    PASS();
-}
-
-// Test shrinking behavior
-void testShrinkingBehavior() {
-    TEST("shrinking behavior when memory usage drops");
-    LargeMemoryAllocator allocator(1024);
-
-    // Allocate large amount
-    void* large1 = allocator.allocate(2048, "LargeMemoryAllocatorTest.cpp:463");
-    void* large2 = allocator.allocate(2048, "LargeMemoryAllocatorTest.cpp:464");
-
-    size_t totalMax = allocator.getTotalMemory();
-    std::cout << "  Max total memory: " << totalMax << std::endl;
-
-    // Free everything - might trigger shrinking
-    allocator.free(large1);
-    allocator.free(large2);
-
-    size_t totalAfter = allocator.getTotalMemory();
-    std::cout << "  Total after free: " << totalAfter << std::endl;
-
-    PASS();
-}
-
-int main() {
-    std::cout << "========================================" << std::endl;
-    std::cout << "LargeMemoryAllocator Test Suite" << std::endl;
-    std::cout << "========================================" << std::endl;
-
-    // Basic functionality tests
-    testBasicAllocation();
-    testMultipleAllocations();
-    testFreeDifferentOrder();
-    testReuseFreedMemory();
-    testLargeAllocation();
-
-    // Memory management tests
-    testBlockSplitting();
-    testAdjacentBlockMerging();
-    testDefragmentation();
-    testMemoryUsageTracking();
-    testAlignment();
-
-    // Stress tests
-    testManySmallAllocations();
-    testGrowingAllocations();
-    testFragmentation();
-    testBestFitStrategy();
-    testShrinkingBehavior();
-
-    // Read/write verification
-    testMemoryReadWrite();
-
-    // Chunk management
-    testChunkRemovalThreshold();
-
-    // Edge cases (these skip actual execution to avoid assertions)
-    testZeroSizedAllocation();
-    testDoubleFree();
-
-    // Bug demonstration tests (skipped to avoid hanging)
-    testBugTriggeringSequence();
-    testInfiniteLoopBugWith32PlusAllocations();
-
-    // Summary
-    std::cout << "\n========================================" << std::endl;
-    std::cout << "Test Summary" << std::endl;
-    std::cout << "========================================" << std::endl;
-    std::cout << "Tests run:    " << testsRun << std::endl;
-    std::cout << "Tests passed: " << testsPassed << std::endl;
-    std::cout << "Tests failed: " << testsFailed << std::endl;
-
-    if (testsFailed == 0) {
-        std::cout << "\n✓ All tests passed!" << std::endl;
-    } else {
-        std::cout << "\n✗ " << testsFailed << " test(s) failed" << std::endl;
-    }
-
-    std::cout << "========================================" << std::endl;
-
-    return (testsFailed > 0) ? 1 : 0;
-}
diff --git a/src/memory/MemoryLeakTest.cpp b/src/memory/MemoryLeakTest.cpp
deleted file mode 100644
index f231efb..0000000
--- a/src/memory/MemoryLeakTest.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-#include "LargeMemoryAllocator.h"
-#include "SmallAllocator.h"
-#include <iostream>
-#include <cassert>
-
-// Test to demonstrate memory leak detection
-void testSmallAllocatorLeakDetection() {
-    std::cout << "\n========================================" << std::endl;
-    std::cout << "Testing SmallAllocator Leak Detection" << std::endl;
-    std::cout << "========================================" << std::endl;
-
-    std::cout << "Creating allocator and leaking memory..." << std::endl;
-    SmallAllocator* allocator = new SmallAllocator();
-
-    // Intentionally leak some allocations
-    void* leak1 = allocator->allocate(128, "MemoryLeakTest.cpp:18");
-    void* leak2 = allocator->allocate(256, "MemoryLeakTest.cpp:19");
-    void* leak3 = allocator->allocate(512, "MemoryLeakTest.cpp:20");
-
-    std::cout << "Allocated 3 blocks that will be leaked" << std::endl;
-    std::cout << "Destroying allocator (should report leaks)..." << std::endl;
-
-    // This will trigger the leak detection in destructor
-    // Note: In production code, this would assert and abort
-    // For testing purposes, we'll catch it
-    delete allocator;
-
-    std::cout << "Test complete (would assert in DEBUG mode)" << std::endl;
-}
-
-void testLargeAllocatorLeakDetection() {
-    std::cout << "\n========================================" << std::endl;
-    std::cout << "Testing LargeMemoryAllocator Leak Detection" << std::endl;
-    std::cout << "========================================" << std::endl;
-
-    std::cout << "Creating allocator and leaking memory..." << std::endl;
-    LargeMemoryAllocator* allocator = new LargeMemoryAllocator(1024 * 1024);
-
-    // Intentionally leak some allocations
-    void* leak1 = allocator->allocate(1024, "MemoryLeakTest.cpp:44");
-    void* leak2 = allocator->allocate(2048, "MemoryLeakTest.cpp:45");
-    void* leak3 = allocator->allocate(4096, "MemoryLeakTest.cpp:46");
-
-    std::cout << "Allocated 3 blocks that will be leaked" << std::endl;
-    std::cout << "Destroying allocator (should report leaks)..." << std::endl;
-
-    // This will trigger the leak detection in destructor
-    // Note: In production code, this would assert and abort
-    // For testing purposes, we'll catch it
-    delete allocator;
-
-    std::cout << "Test complete (would assert in DEBUG mode)" << std::endl;
-}
-
-int main() {
-    std::cout << "Memory Leak Detection Test" << std::endl;
-    std::cout << "This test intentionally leaks memory to demonstrate leak detection" << std::endl;
-    std::cout << "In DEBUG mode, these would trigger assertions" << std::endl;
-
-    // Comment out the actual test calls since they would assert
-    // Uncomment to see leak detection in action (will abort in DEBUG mode)
-    // testSmallAllocatorLeakDetection();
-    // testLargeAllocatorLeakDetection();
-
-    std::cout << "\nTo see leak detection in action:" << std::endl;
-    std::cout << "1. Uncomment the test function calls in main()" << std::endl;
-    std::cout << "2. Comment out the 'assert(allocationCount_ == 0)' lines temporarily" << std::endl;
-    std::cout << "3. Rebuild and run to see leak reporting" << std::endl;
-
-    return 0;
-}
diff --git a/src/memory/SmallAllocator.cpp b/src/memory/SmallAllocator.cpp
index 54795fd..fb4061b 100644
--- a/src/memory/SmallAllocator.cpp
+++ b/src/memory/SmallAllocator.cpp
@@ -427,7 +427,6 @@ SmallAllocator::MemoryPoolInfo* SmallAllocator::getPoolInfo(size_t* outPoolCount
             poolInfo[i].blocks[j].offset = (char*)block - pool->memory;
             poolInfo[i].blocks[j].size = block->size;
             poolInfo[i].blocks[j].isFree = block->isFree;
-            poolInfo[i].blocks[j].allocationId = block->allocationId;
             block = block->next;
         }
 
diff --git a/src/memory/SmallAllocator.h b/src/memory/SmallAllocator.h
index a13f917..297a260 100644
--- a/src/memory/SmallAllocator.h
+++ b/src/memory/SmallAllocator.h
@@ -39,7 +39,6 @@ public:
         size_t offset;      // Offset from pool start
         size_t size;        // Size of block
         bool isFree;        // Is this block free?
-        const char* allocationId; // Identifier for tracking allocation source
     };
 
     struct MemoryPoolInfo {
diff --git a/src/resources/resource.cpp b/src/resources/resource.cpp
index 034ea35..343e138 100644
--- a/src/resources/resource.cpp
+++ b/src/resources/resource.cpp
@@ -15,11 +15,16 @@
 #include <unistd.h>
 #endif
 
-PakResource::PakResource(MemoryAllocator* allocator) : m_pakData{nullptr, 0}, m_allocator(allocator)
+PakResource::PakResource(MemoryAllocator* allocator)
+    : m_pakData{nullptr, 0}
+    , m_decompressedData(*allocator, "PakResource::m_decompressedData")
+    , m_atlasUVCache(*allocator, "PakResource::m_atlasUVCache")
+    , m_allocator(allocator)
 #ifdef _WIN32
-, m_hFile(INVALID_HANDLE_VALUE), m_hMapping(NULL)
+    , m_hFile(INVALID_HANDLE_VALUE)
+    , m_hMapping(NULL)
 #else
-, m_fd(-1)
+    , m_fd(-1)
 #endif
 {
     assert(m_allocator != nullptr);
@@ -28,6 +33,13 @@ PakResource::PakResource(MemoryAllocator* allocator) : m_pakData{nullptr, 0}, m_
 }
 
 PakResource::~PakResource() {
+    // Clean up decompressed data
+    for (auto it = m_decompressedData.begin(); it != m_decompressedData.end(); ++it) {
+        Vector<char>* vec = it.value();
+        vec->~Vector<char>();
+        m_allocator->free(vec);
+    }
+    
     if (m_pakData.data) {
 #ifdef _WIN32
         if (m_pakData.data) UnmapViewOfFile(m_pakData.data);
@@ -101,7 +113,12 @@ bool PakResource::reload(const char* filename) {
 #endif
         m_pakData = {nullptr, 0};
     }
-    // Clear caches
+    // Clear caches - first free allocated Vector objects
+    for (auto it = m_decompressedData.begin(); it != m_decompressedData.end(); ++it) {
+        Vector<char>* vec = it.value();
+        vec->~Vector<char>();
+        m_allocator->free(vec);
+    }
     m_decompressedData.clear();
     m_atlasUVCache.clear();
     // Load again
@@ -137,27 +154,33 @@ ResourceData PakResource::getResource(uint64_t id) {
                 return result;
             } else if (comp->compressionType == COMPRESSION_FLAGS_LZ4) {
                 // Check if already decompressed (cache hit)
-                auto it = m_decompressedData.find(id);
-                if (it != m_decompressedData.end()) {
+                Vector<char>** cachedDataPtr = m_decompressedData.find(id);
+                if (cachedDataPtr != nullptr) {
                     std::cout << "Resource " << id << ": cache hit (" << comp->decompressedSize << " bytes)" << std::endl;
-                    ResourceData result = ResourceData{(char*)it->second.data(), comp->decompressedSize, comp->type};
+                    ResourceData result = ResourceData{(char*)(*cachedDataPtr)->data(), comp->decompressedSize, comp->type};
                     SDL_UnlockMutex(m_mutex);
                     return result;
                 }
                 // Cache miss - decompress
                 std::cout << "Resource " << id << ": cache miss, decompressing " << comp->compressedSize << " -> " << comp->decompressedSize << " bytes" << std::endl;
-                Vector<char> decompressed(*m_allocator, "ResourceManager::getResource::decompressed");
-                decompressed.resize(comp->decompressedSize);
-                int result = LZ4_decompress_safe(compressedData, decompressed.data(), comp->compressedSize, comp->decompressedSize);
+                
+                // Allocate Vector using memory allocator
+                void* vecMem = m_allocator->allocate(sizeof(Vector<char>), "PakResource::getResource::Vector");
+                Vector<char>* decompressed = new (vecMem) Vector<char>(*m_allocator, "PakResource::getResource::decompressed");
+                decompressed->resize(comp->decompressedSize);
+                
+                int result = LZ4_decompress_safe(compressedData, decompressed->data(), comp->compressedSize, comp->decompressedSize);
                 if (result != (int)comp->decompressedSize) {
                     std::cerr << "LZ4 decompression failed for resource " << id << std::endl;
+                    decompressed->~Vector<char>();
+                    m_allocator->free(vecMem);
                     SDL_UnlockMutex(m_mutex);
                     assert(false);
                     return ResourceData{nullptr, 0, 0};
                 }
-                m_decompressedData.insert({id, std::move(decompressed)});
-                it = m_decompressedData.find(id);
-                ResourceData resData = ResourceData{(char*)it->second.data(), comp->decompressedSize, comp->type};
+                
+                m_decompressedData.insert(id, decompressed);
+                ResourceData resData = ResourceData{(char*)decompressed->data(), comp->decompressedSize, comp->type};
                 SDL_UnlockMutex(m_mutex);
                 return resData;
             }
@@ -174,9 +197,9 @@ bool PakResource::getAtlasUV(uint64_t textureId, AtlasUV& uv) {
     SDL_LockMutex(m_mutex);
 
     // Check cache first
-    auto cacheIt = m_atlasUVCache.find(textureId);
-    if (cacheIt != m_atlasUVCache.end()) {
-        uv = cacheIt->second;
+    AtlasUV* cachedUV = m_atlasUVCache.find(textureId);
+    if (cachedUV != nullptr) {
+        uv = *cachedUV;
         SDL_UnlockMutex(m_mutex);
         return true;
     }
@@ -230,7 +253,7 @@ bool PakResource::getAtlasUV(uint64_t textureId, AtlasUV& uv) {
 
         // Cache the result
         SDL_LockMutex(m_mutex);
-        m_atlasUVCache[textureId] = uv;
+        m_atlasUVCache.insert(textureId, uv);
         SDL_UnlockMutex(m_mutex);
 
         return true;
@@ -282,7 +305,8 @@ void PakResource::preloadResourceAsync(uint64_t id) {
 
 bool PakResource::isResourceReady(uint64_t id) {
     SDL_LockMutex(m_mutex);
-    bool ready = m_decompressedData.find(id) != m_decompressedData.end();
+    Vector<char>** vecPtr = m_decompressedData.find(id);
+    bool ready = (vecPtr != nullptr);
     SDL_UnlockMutex(m_mutex);
     return ready;
 }
\ No newline at end of file
diff --git a/src/resources/resource.h b/src/resources/resource.h
index 2ad2f13..c2430bd 100644
--- a/src/resources/resource.h
+++ b/src/resources/resource.h
@@ -2,9 +2,9 @@
 
 #include <cstddef>
 #include <cstdint>
-#include <map>
 #include <SDL3/SDL.h>
 #include "../core/Vector.h"
+#include "../core/HashTable.h"
 
 // Forward declarations
 class MemoryAllocator;
@@ -46,8 +46,8 @@ public:
 
 private:
     ResourceData m_pakData;
-    std::map<uint64_t, Vector<char>> m_decompressedData;
-    std::map<uint64_t, AtlasUV> m_atlasUVCache;  // Cache of atlas UV lookups
+    HashTable<uint64_t, Vector<char>*> m_decompressedData;
+    HashTable<uint64_t, AtlasUV> m_atlasUVCache;  // Cache of atlas UV lookups
     SDL_Mutex* m_mutex;
     MemoryAllocator* m_allocator;
 
diff --git a/src/vulkan/VulkanDescriptor.cpp b/src/vulkan/VulkanDescriptor.cpp
index 021cba8..dcd5bc6 100644
--- a/src/vulkan/VulkanDescriptor.cpp
+++ b/src/vulkan/VulkanDescriptor.cpp
@@ -19,22 +19,26 @@ static const char* vkResultToString(VkResult result) {
     }
 }
 
-VulkanDescriptor::VulkanDescriptor() :
+VulkanDescriptor::VulkanDescriptor(MemoryAllocator* allocator) :
     m_device(VK_NULL_HANDLE),
     m_textureManager(nullptr),
     m_initialized(false),
     m_singleTextureDescriptorSetLayout(VK_NULL_HANDLE),
     m_singleTextureDescriptorPool(VK_NULL_HANDLE),
+    m_singleTextureDescriptorSets(*allocator, "VulkanDescriptor::m_singleTextureDescriptorSets"),
     m_singleTexturePipelineLayout(VK_NULL_HANDLE),
     m_dualTextureDescriptorSetLayout(VK_NULL_HANDLE),
     m_dualTextureDescriptorPool(VK_NULL_HANDLE),
+    m_dualTextureDescriptorSets(*allocator, "VulkanDescriptor::m_dualTextureDescriptorSets"),
     m_dualTexturePipelineLayout(VK_NULL_HANDLE),
     m_animSingleTexturePipelineLayout(VK_NULL_HANDLE),
     m_animDualTexturePipelineLayout(VK_NULL_HANDLE),
     m_lightDescriptorSetLayout(VK_NULL_HANDLE),
     m_lightDescriptorPool(VK_NULL_HANDLE),
-    m_lightDescriptorSet(VK_NULL_HANDLE)
+    m_lightDescriptorSet(VK_NULL_HANDLE),
+    m_allocator(allocator)
 {
+    assert(m_allocator != nullptr);
 }
 
 VulkanDescriptor::~VulkanDescriptor() {
@@ -237,7 +241,7 @@ void VulkanDescriptor::createLightDescriptorPool() {
 }
 
 void VulkanDescriptor::createSingleTextureDescriptorSet(uint64_t textureId, VkImageView imageView, VkSampler sampler) {
-    if (m_singleTextureDescriptorSets.find(textureId) != m_singleTextureDescriptorSets.end()) {
+    if (m_singleTextureDescriptorSets.find(textureId) != nullptr) {
         return;
     }
 
@@ -266,11 +270,11 @@ void VulkanDescriptor::createSingleTextureDescriptorSet(uint64_t textureId, VkIm
 
     vkUpdateDescriptorSets(m_device, 1, &descriptorWrite, 0, nullptr);
 
-    m_singleTextureDescriptorSets[textureId] = descriptorSet;
+    m_singleTextureDescriptorSets.insert(textureId, descriptorSet);
 }
 
 void VulkanDescriptor::createDualTextureDescriptorSet(uint64_t descriptorId, uint64_t texture1Id, uint64_t texture2Id) {
-    if (m_dualTextureDescriptorSets.find(descriptorId) != m_dualTextureDescriptorSets.end()) {
+    if (m_dualTextureDescriptorSets.find(descriptorId) != nullptr) {
         return;
     }
 
@@ -325,14 +329,14 @@ void VulkanDescriptor::createDualTextureDescriptorSet(uint64_t descriptorId, uin
 
     vkUpdateDescriptorSets(m_device, 2, descriptorWrites, 0, nullptr);
 
-    m_dualTextureDescriptorSets[descriptorId] = descriptorSet;
+    m_dualTextureDescriptorSets.insert(descriptorId, descriptorSet);
 }
 
 void VulkanDescriptor::createDescriptorSetForTextures(uint64_t descriptorId, const Vector<uint64_t>& textureIds) {
     if (textureIds.size() == 1) {
-        auto it = m_singleTextureDescriptorSets.find(textureIds[0]);
-        if (it != m_singleTextureDescriptorSets.end()) {
-            m_singleTextureDescriptorSets[descriptorId] = it->second;
+        const VkDescriptorSet* descSetPtr = m_singleTextureDescriptorSets.find(textureIds[0]);
+        if (descSetPtr != nullptr) {
+            m_singleTextureDescriptorSets.insert(descriptorId, *descSetPtr);
         }
     } else if (textureIds.size() == 2) {
         createDualTextureDescriptorSet(descriptorId, textureIds[0], textureIds[1]);
@@ -366,51 +370,53 @@ void VulkanDescriptor::createLightDescriptorSet(VkBuffer lightUniformBuffer, VkD
 }
 
 VkDescriptorSet VulkanDescriptor::getSingleTextureDescriptorSet(uint64_t textureId) const {
-    auto it = m_singleTextureDescriptorSets.find(textureId);
-    if (it != m_singleTextureDescriptorSets.end()) {
-        return it->second;
+    const VkDescriptorSet* descSetPtr = m_singleTextureDescriptorSets.find(textureId);
+    if (descSetPtr != nullptr) {
+        return *descSetPtr;
     }
     return VK_NULL_HANDLE;
 }
 
 VkDescriptorSet VulkanDescriptor::getDualTextureDescriptorSet(uint64_t descriptorId) const {
-    auto it = m_dualTextureDescriptorSets.find(descriptorId);
-    if (it != m_dualTextureDescriptorSets.end()) {
-        return it->second;
+    const VkDescriptorSet* descSetPtr = m_dualTextureDescriptorSets.find(descriptorId);
+    if (descSetPtr != nullptr) {
+        return *descSetPtr;
     }
     return VK_NULL_HANDLE;
 }
 
 bool VulkanDescriptor::hasSingleTextureDescriptorSet(uint64_t textureId) const {
-    return m_singleTextureDescriptorSets.find(textureId) != m_singleTextureDescriptorSets.end();
+    return m_singleTextureDescriptorSets.find(textureId) != nullptr;
 }
 
 bool VulkanDescriptor::hasDualTextureDescriptorSet(uint64_t descriptorId) const {
-    return m_dualTextureDescriptorSets.find(descriptorId) != m_dualTextureDescriptorSets.end();
+    return m_dualTextureDescriptorSets.find(descriptorId) != nullptr;
 }
 
 VkDescriptorSet VulkanDescriptor::getOrCreateDescriptorSet(uint64_t descriptorId, uint64_t textureId,
                                                            uint64_t normalMapId, bool usesDualTexture) {
     if (usesDualTexture) {
-        auto it = m_dualTextureDescriptorSets.find(descriptorId);
-        if (it != m_dualTextureDescriptorSets.end()) {
-            return it->second;
+        const VkDescriptorSet* descSetPtr = m_dualTextureDescriptorSets.find(descriptorId);
+        if (descSetPtr != nullptr) {
+            return *descSetPtr;
         }
 
         if (normalMapId != 0) {
             createDualTextureDescriptorSet(descriptorId, textureId, normalMapId);
-            return m_dualTextureDescriptorSets[descriptorId];
+            const VkDescriptorSet* newDescSetPtr = m_dualTextureDescriptorSets.find(descriptorId);
+            assert(newDescSetPtr != nullptr);
+            return *newDescSetPtr;
         }
     } else {
-        auto it = m_singleTextureDescriptorSets.find(descriptorId);
-        if (it != m_singleTextureDescriptorSets.end()) {
-            return it->second;
+        const VkDescriptorSet* descSetPtr = m_singleTextureDescriptorSets.find(descriptorId);
+        if (descSetPtr != nullptr) {
+            return *descSetPtr;
         }
 
-        auto texIt = m_singleTextureDescriptorSets.find(textureId);
-        if (texIt != m_singleTextureDescriptorSets.end()) {
-            m_singleTextureDescriptorSets[descriptorId] = texIt->second;
-            return texIt->second;
+        const VkDescriptorSet* texDescSetPtr = m_singleTextureDescriptorSets.find(textureId);
+        if (texDescSetPtr != nullptr) {
+            m_singleTextureDescriptorSets.insert(descriptorId, *texDescSetPtr);
+            return *texDescSetPtr;
         }
     }
 
diff --git a/src/vulkan/VulkanDescriptor.h b/src/vulkan/VulkanDescriptor.h
index 4910220..ab09e03 100644
--- a/src/vulkan/VulkanDescriptor.h
+++ b/src/vulkan/VulkanDescriptor.h
@@ -2,7 +2,7 @@
 
 #include <vulkan/vulkan.h>
 #include "../core/Vector.h"
-#include <map>
+#include "../core/HashTable.h"
 #include <vector>
 #include <cstdint>
 
@@ -13,7 +13,7 @@ class MemoryAllocator;
 // Helper class for managing Vulkan descriptor sets, pools, and layouts
 class VulkanDescriptor {
 public:
-    VulkanDescriptor();
+    VulkanDescriptor(MemoryAllocator* allocator);
     ~VulkanDescriptor();
 
     // Initialization - must be called before any other operations
@@ -66,10 +66,10 @@ public:
                                              uint64_t normalMapId, bool usesDualTexture);
 
     // Access for iteration
-    const std::map<uint64_t, VkDescriptorSet>& getSingleTextureDescriptorSets() const {
+    const HashTable<uint64_t, VkDescriptorSet>& getSingleTextureDescriptorSets() const {
         return m_singleTextureDescriptorSets;
     }
-    const std::map<uint64_t, VkDescriptorSet>& getDualTextureDescriptorSets() const {
+    const HashTable<uint64_t, VkDescriptorSet>& getDualTextureDescriptorSets() const {
         return m_dualTextureDescriptorSets;
     }
 
@@ -81,13 +81,13 @@ private:
     // Single texture descriptors
     VkDescriptorSetLayout m_singleTextureDescriptorSetLayout;
     VkDescriptorPool m_singleTextureDescriptorPool;
-    std::map<uint64_t, VkDescriptorSet> m_singleTextureDescriptorSets;
+    HashTable<uint64_t, VkDescriptorSet> m_singleTextureDescriptorSets;
     VkPipelineLayout m_singleTexturePipelineLayout;
 
     // Dual texture descriptors
     VkDescriptorSetLayout m_dualTextureDescriptorSetLayout;
     VkDescriptorPool m_dualTextureDescriptorPool;
-    std::map<uint64_t, VkDescriptorSet> m_dualTextureDescriptorSets;
+    HashTable<uint64_t, VkDescriptorSet> m_dualTextureDescriptorSets;
     VkPipelineLayout m_dualTexturePipelineLayout;
 
     // Animation pipeline layouts (extended push constants)
@@ -98,4 +98,6 @@ private:
     VkDescriptorSetLayout m_lightDescriptorSetLayout;
     VkDescriptorPool m_lightDescriptorPool;
     VkDescriptorSet m_lightDescriptorSet;
+
+    MemoryAllocator* m_allocator;
 };
diff --git a/src/vulkan/VulkanLight.cpp b/src/vulkan/VulkanLight.cpp
index e24f944..96b9eaf 100644
--- a/src/vulkan/VulkanLight.cpp
+++ b/src/vulkan/VulkanLight.cpp
@@ -1,7 +1,7 @@
 #include "VulkanLight.h"
 #include <cassert>
 
-VulkanLight::VulkanLight() :
+VulkanLight::VulkanLight(MemoryAllocator* allocator) :
     m_device(VK_NULL_HANDLE),
     m_physicalDevice(VK_NULL_HANDLE),
     m_initialized(false),
@@ -9,8 +9,11 @@ VulkanLight::VulkanLight() :
     m_lightUniformBufferMemory(VK_NULL_HANDLE),
     m_lightUniformBufferMapped(nullptr),
     m_nextLightId(1),
-    m_lightBufferDirty(true)
+    m_lightIdToIndex(*allocator, "VulkanLight::m_lightIdToIndex"),
+    m_lightBufferDirty(true),
+    m_allocator(allocator)
 {
+    assert(m_allocator != nullptr);
     memset(&m_lightBufferData, 0, sizeof(m_lightBufferData));
     m_lightBufferData.numLights = 0;
     m_lightBufferData.ambientR = 0.1f;
@@ -105,19 +108,19 @@ int VulkanLight::addLight(float x, float y, float z, float r, float g, float b,
     m_lightBufferData.lights[index].intensity = intensity;
     m_lightBufferData.numLights++;
 
-    m_lightIdToIndex[lightId] = index;
+    m_lightIdToIndex.insert(lightId, index);
     m_lightBufferDirty = true;
 
     return lightId;
 }
 
 void VulkanLight::updateLight(int lightId, float x, float y, float z, float r, float g, float b, float intensity) {
-    auto it = m_lightIdToIndex.find(lightId);
-    if (it == m_lightIdToIndex.end()) {
+    int* indexPtr = m_lightIdToIndex.find(lightId);
+    if (indexPtr == nullptr) {
         return;
     }
 
-    int index = it->second;
+    int index = *indexPtr;
     m_lightBufferData.lights[index].posX = x;
     m_lightBufferData.lights[index].posY = y;
     m_lightBufferData.lights[index].posZ = z;
@@ -129,12 +132,12 @@ void VulkanLight::updateLight(int lightId, float x, float y, float z, float r, f
 }
 
 void VulkanLight::removeLight(int lightId) {
-    auto it = m_lightIdToIndex.find(lightId);
-    if (it == m_lightIdToIndex.end()) {
+    int* indexPtr = m_lightIdToIndex.find(lightId);
+    if (indexPtr == nullptr) {
         return;
     }
 
-    int indexToRemove = it->second;
+    int indexToRemove = *indexPtr;
     int lastIndex = m_lightBufferData.numLights - 1;
 
     // If not the last light, swap with the last one
@@ -142,16 +145,16 @@ void VulkanLight::removeLight(int lightId) {
         m_lightBufferData.lights[indexToRemove] = m_lightBufferData.lights[lastIndex];
 
         // Update the index mapping for the swapped light
-        for (auto& pair : m_lightIdToIndex) {
-            if (pair.second == lastIndex) {
-                pair.second = indexToRemove;
+        for (auto it = m_lightIdToIndex.begin(); it != m_lightIdToIndex.end(); ++it) {
+            if (it.value() == lastIndex) {
+                m_lightIdToIndex.insert(it.key(), indexToRemove);
                 break;
             }
         }
     }
 
     m_lightBufferData.numLights--;
-    m_lightIdToIndex.erase(it);
+    m_lightIdToIndex.remove(lightId);
     m_lightBufferDirty = true;
 }
 
diff --git a/src/vulkan/VulkanLight.h b/src/vulkan/VulkanLight.h
index acb6619..544f5f7 100644
--- a/src/vulkan/VulkanLight.h
+++ b/src/vulkan/VulkanLight.h
@@ -1,7 +1,8 @@
 #pragma once
 
 #include <vulkan/vulkan.h>
-#include <map>
+#include "../core/HashTable.h"
+#include "../memory/MemoryAllocator.h"
 #include <cstdint>
 #include <cstring>
 
@@ -28,7 +29,7 @@ struct LightBufferData {
 // Helper class for managing Vulkan light system
 class VulkanLight {
 public:
-    VulkanLight();
+    VulkanLight(MemoryAllocator* allocator);
     ~VulkanLight();
 
     // Initialization - must be called before any other operations
@@ -70,6 +71,7 @@ private:
 
     // Light tracking
     int m_nextLightId;
-    std::map<int, int> m_lightIdToIndex;
+    HashTable<int, int> m_lightIdToIndex;
     bool m_lightBufferDirty;
+    MemoryAllocator* m_allocator;
 };
diff --git a/src/vulkan/VulkanPipeline.cpp b/src/vulkan/VulkanPipeline.cpp
index 0a17391..9f16fae 100644
--- a/src/vulkan/VulkanPipeline.cpp
+++ b/src/vulkan/VulkanPipeline.cpp
@@ -23,10 +23,18 @@ VulkanPipeline::VulkanPipeline(MemoryAllocator* allocator) :
     m_descriptorManager(nullptr),
     m_initialized(false),
     m_pipelineLayout(VK_NULL_HANDLE),
+    m_pipelines(*allocator, "VulkanPipeline::m_pipelines"),
+    m_debugPipelines(*allocator, "VulkanPipeline::m_debugPipelines"),
     m_debugLinePipeline(VK_NULL_HANDLE),
     m_debugTrianglePipeline(VK_NULL_HANDLE),
     m_currentPipeline(VK_NULL_HANDLE),
     m_pipelinesToDraw(*allocator, "VulkanPipeline::m_pipelinesToDraw"),
+    m_pipelineInfo(*allocator, "VulkanPipeline::m_pipelineInfo"),
+    m_pipelineShaderParams(*allocator, "VulkanPipeline::m_pipelineShaderParams"),
+    m_pipelineShaderParamCount(*allocator, "VulkanPipeline::m_pipelineShaderParamCount"),
+    m_pipelineParallaxDepth(*allocator, "VulkanPipeline::m_pipelineParallaxDepth"),
+    m_pipelineWaterRipples(*allocator, "VulkanPipeline::m_pipelineWaterRipples"),
+    m_pipelineWaterRippleCount(*allocator, "VulkanPipeline::m_pipelineWaterRippleCount"),
     m_vertShaderData(*allocator, "VulkanPipeline::m_vertShaderData"),
     m_fragShaderData(*allocator, "VulkanPipeline::m_fragShaderData"),
     m_allocator(allocator)
@@ -46,9 +54,9 @@ void VulkanPipeline::init(VkDevice device, VkRenderPass renderPass, VkSampleCoun
 }
 
 void VulkanPipeline::cleanup() {
-    for (auto& pair : m_pipelines) {
-        if (pair.second != VK_NULL_HANDLE) {
-            vkDestroyPipeline(m_device, pair.second, nullptr);
+    for (auto it = m_pipelines.begin(); it != m_pipelines.end(); ++it) {
+        if (it.value() != VK_NULL_HANDLE) {
+            vkDestroyPipeline(m_device, it.value(), nullptr);
         }
     }
     m_pipelines.clear();
@@ -66,6 +74,12 @@ void VulkanPipeline::cleanup() {
         m_pipelineLayout = VK_NULL_HANDLE;
     }
 
+    // Delete all dynamically allocated PipelineInfo objects
+    for (auto it = m_pipelineInfo.begin(); it != m_pipelineInfo.end(); ++it) {
+        PipelineInfo* info = it.value();
+        info->~PipelineInfo();
+        m_allocator->free(info);
+    }
     m_pipelineInfo.clear();
     m_debugPipelines.clear();
     m_pipelineShaderParams.clear();
@@ -268,7 +282,7 @@ void VulkanPipeline::createPipeline(uint64_t id, const ResourceData& vertShader,
             assert(false);
         }
 
-        m_debugPipelines[id] = true;
+        m_debugPipelines.insert(id, true);
     } else {
         VkPipeline pipeline;
         result = vkCreateGraphicsPipelines(m_device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline);
@@ -277,8 +291,8 @@ void VulkanPipeline::createPipeline(uint64_t id, const ResourceData& vertShader,
             assert(false);
         }
 
-        m_pipelines[id] = pipeline;
-        m_debugPipelines[id] = false;
+        m_pipelines.insert(id, pipeline);
+        m_debugPipelines.insert(id, false);
     }
 
     vkDestroyShaderModule(m_device, fragShaderModule, nullptr);
@@ -460,17 +474,18 @@ void VulkanPipeline::createTexturedPipeline(uint64_t id, const ResourceData& ver
         assert(false);
     }
 
-    m_pipelines[id] = pipeline;
+    m_pipelines.insert(id, pipeline);
 
-    PipelineInfo info;
-    info.layout = pipelineLayout;
-    info.descriptorSetLayout = descriptorSetLayout;
-    info.usesDualTexture = usesDualTexture;
-    info.usesExtendedPushConstants = false;
-    info.usesAnimationPushConstants = false;
-    info.isParticlePipeline = false;
-    info.isWaterPipeline = false;
-    m_pipelineInfo[id] = info;
+    void* infoMem = m_allocator->allocate(sizeof(PipelineInfo), "VulkanPipeline::createTexturedPipeline::PipelineInfo");
+    PipelineInfo* info = new (infoMem) PipelineInfo();
+    info->layout = pipelineLayout;
+    info->descriptorSetLayout = descriptorSetLayout;
+    info->usesDualTexture = usesDualTexture;
+    info->usesExtendedPushConstants = false;
+    info->usesAnimationPushConstants = false;
+    info->isParticlePipeline = false;
+    info->isWaterPipeline = false;
+    m_pipelineInfo.insert(id, info);
 
     vkDestroyShaderModule(m_device, fragShaderModule, nullptr);
     vkDestroyShaderModule(m_device, vertShaderModule, nullptr);
@@ -651,17 +666,18 @@ void VulkanPipeline::createTexturedPipelineAdditive(uint64_t id, const ResourceD
         assert(false);
     }
 
-    m_pipelines[id] = pipeline;
+    m_pipelines.insert(id, pipeline);
 
-    PipelineInfo info;
-    info.layout = pipelineLayout;
-    info.descriptorSetLayout = descriptorSetLayout;
-    info.usesDualTexture = usesDualTexture;
-    info.usesExtendedPushConstants = false;
-    info.usesAnimationPushConstants = false;
-    info.isParticlePipeline = false;
-    info.isWaterPipeline = false;
-    m_pipelineInfo[id] = info;
+    void* infoMem = m_allocator->allocate(sizeof(PipelineInfo), "VulkanPipeline::createTexturedPipelineAdditive::PipelineInfo");
+    PipelineInfo* info = new (infoMem) PipelineInfo();
+    info->layout = pipelineLayout;
+    info->descriptorSetLayout = descriptorSetLayout;
+    info->usesDualTexture = usesDualTexture;
+    info->usesExtendedPushConstants = false;
+    info->usesAnimationPushConstants = false;
+    info->isParticlePipeline = false;
+    info->isWaterPipeline = false;
+    m_pipelineInfo.insert(id, info);
 
     vkDestroyShaderModule(m_device, fragShaderModule, nullptr);
     vkDestroyShaderModule(m_device, vertShaderModule, nullptr);
@@ -843,17 +859,18 @@ void VulkanPipeline::createAnimTexturedPipeline(uint64_t id, const ResourceData&
         assert(false);
     }
 
-    m_pipelines[id] = pipeline;
+    m_pipelines.insert(id, pipeline);
 
-    PipelineInfo info;
-    info.layout = pipelineLayout;
-    info.descriptorSetLayout = descriptorSetLayout;
-    info.usesDualTexture = usesDualTexture;
-    info.usesExtendedPushConstants = true;
-    info.usesAnimationPushConstants = true;
-    info.isParticlePipeline = false;
-    info.isWaterPipeline = false;
-    m_pipelineInfo[id] = info;
+    void* infoMem = m_allocator->allocate(sizeof(PipelineInfo), "VulkanPipeline::createAnimTexturedPipeline::PipelineInfo");
+    PipelineInfo* info = new (infoMem) PipelineInfo();
+    info->layout = pipelineLayout;
+    info->descriptorSetLayout = descriptorSetLayout;
+    info->usesDualTexture = usesDualTexture;
+    info->usesExtendedPushConstants = true;
+    info->usesAnimationPushConstants = true;
+    info->isParticlePipeline = false;
+    info->isWaterPipeline = false;
+    m_pipelineInfo.insert(id, info);
 
     vkDestroyShaderModule(m_device, fragShaderModule, nullptr);
     vkDestroyShaderModule(m_device, vertShaderModule, nullptr);
@@ -1017,90 +1034,88 @@ void VulkanPipeline::createParticlePipeline(uint64_t id, const ResourceData& ver
         assert(false);
     }
 
-    m_pipelines[id] = pipeline;
+    m_pipelines.insert(id, pipeline);
 
-    PipelineInfo info;
-    info.layout = m_descriptorManager->getSingleTexturePipelineLayout();
-    info.descriptorSetLayout = m_descriptorManager->getSingleTextureLayout();
-    info.usesDualTexture = false;
-    info.usesExtendedPushConstants = false;
-    info.usesAnimationPushConstants = false;
-    info.isParticlePipeline = true;
-    info.isWaterPipeline = false;
-    m_pipelineInfo[id] = info;
+    void* infoMem = m_allocator->allocate(sizeof(PipelineInfo), "VulkanPipeline::createParticlePipeline::PipelineInfo");
+    PipelineInfo* info = new (infoMem) PipelineInfo();
+    info->layout = m_descriptorManager->getSingleTexturePipelineLayout();
+    info->descriptorSetLayout = m_descriptorManager->getSingleTextureLayout();
+    info->usesDualTexture = false;
+    info->usesExtendedPushConstants = false;
+    info->usesAnimationPushConstants = false;
+    info->isParticlePipeline = true;
+    info->isWaterPipeline = false;
+    m_pipelineInfo.insert(id, info);
 
     vkDestroyShaderModule(m_device, fragShaderModule, nullptr);
     vkDestroyShaderModule(m_device, vertShaderModule, nullptr);
 }
 
 VkPipeline VulkanPipeline::getPipeline(uint64_t id) const {
-    auto it = m_pipelines.find(id);
-    if (it != m_pipelines.end()) {
-        return it->second;
+    const VkPipeline* pipelinePtr = m_pipelines.find(id);
+    if (pipelinePtr != nullptr) {
+        return *pipelinePtr;
     }
     return VK_NULL_HANDLE;
 }
 
 bool VulkanPipeline::hasPipeline(uint64_t id) const {
-    return m_pipelines.find(id) != m_pipelines.end();
+    return m_pipelines.find(id) != nullptr;
 }
 
 bool VulkanPipeline::isDebugPipeline(uint64_t id) const {
-    auto it = m_debugPipelines.find(id);
-    return it != m_debugPipelines.end() && it->second;
+    const bool* isDebugPtr = m_debugPipelines.find(id);
+    return isDebugPtr != nullptr && *isDebugPtr;
 }
 
 const PipelineInfo* VulkanPipeline::getPipelineInfo(uint64_t id) const {
-    auto it = m_pipelineInfo.find(id);
-    if (it != m_pipelineInfo.end()) {
-        return &it->second;
-    }
-    return nullptr;
+    PipelineInfo* const* infoPtr = m_pipelineInfo.find(id);
+    return infoPtr ? *infoPtr : nullptr;
 }
 
 PipelineInfo* VulkanPipeline::getPipelineInfoMutable(uint64_t id) {
-    auto it = m_pipelineInfo.find(id);
-    if (it != m_pipelineInfo.end()) {
-        return &it->second;
-    }
-    return nullptr;
+    PipelineInfo** infoPtr = m_pipelineInfo.find(id);
+    return infoPtr ? *infoPtr : nullptr;
 }
 
 void VulkanPipeline::associateDescriptorWithPipeline(uint64_t pipelineId, uint64_t descriptorId) {
-    auto it = m_pipelineInfo.find(pipelineId);
-    if (it != m_pipelineInfo.end()) {
-        it->second.descriptorIds.insert(descriptorId);
+    PipelineInfo** infoPtrPtr = m_pipelineInfo.find(pipelineId);
+    if (infoPtrPtr != nullptr) {
+        (*infoPtrPtr)->descriptorIds.insert(descriptorId);
     }
 }
 
 void VulkanPipeline::setShaderParameters(int pipelineId, int paramCount, const float* params) {
-    m_pipelineShaderParamCount[pipelineId] = paramCount;
+    m_pipelineShaderParamCount.insert(pipelineId, paramCount);
+
+    std::array<float, 7> paramsArray;
     for (int i = 0; i < paramCount && i < 7; ++i) {
-        m_pipelineShaderParams[pipelineId][i] = params[i];
+        paramsArray[i] = params[i];
     }
     for (int i = paramCount; i < 7; ++i) {
-        m_pipelineShaderParams[pipelineId][i] = 0.0f;
+        paramsArray[i] = 0.0f;
     }
+    m_pipelineShaderParams.insert(pipelineId, paramsArray);
 
-    auto infoIt = m_pipelineInfo.find(pipelineId);
-    if (infoIt != m_pipelineInfo.end()) {
-        infoIt->second.usesExtendedPushConstants = true;
+    PipelineInfo** infoPtrPtr = m_pipelineInfo.find(pipelineId);
+    if (infoPtrPtr != nullptr) {
+        (*infoPtrPtr)->usesExtendedPushConstants = true;
     }
 }
 
 const std::array<float, 7>& VulkanPipeline::getShaderParams(int pipelineId) const {
     static const std::array<float, 7> defaultParams = {0, 0, 0, 0, 0, 0, 0};
-    auto it = m_pipelineShaderParams.find(pipelineId);
-    if (it != m_pipelineShaderParams.end()) {
-        return it->second;
+    const std::array<float, 7>* paramsPtr = m_pipelineShaderParams.find(pipelineId);
+    if (paramsPtr != nullptr) {
+        return *paramsPtr;
     }
     return defaultParams;
 }
 
 int VulkanPipeline::getShaderParamCount(int pipelineId) const {
-    auto it = m_pipelineShaderParamCount.find(pipelineId);
-    if (it != m_pipelineShaderParamCount.end()) {
-        return it->second;
+    const int* countPtr = m_pipelineShaderParamCount.find(pipelineId);
+    if (countPtr != nullptr) {
+        return *countPtr;
     }
     return 0;
 }
@@ -1109,61 +1124,72 @@ void VulkanPipeline::setWaterRipples(int pipelineId, int rippleCount, const Shad
     if (rippleCount > MAX_SHADER_RIPPLES) {
         rippleCount = MAX_SHADER_RIPPLES;
     }
-    m_pipelineWaterRippleCount[pipelineId] = rippleCount;
+    m_pipelineWaterRippleCount.insert(pipelineId, rippleCount);
+
+    std::array<ShaderRippleData, MAX_SHADER_RIPPLES> ripplesArray;
     for (int i = 0; i < rippleCount; ++i) {
-        m_pipelineWaterRipples[pipelineId][i] = ripples[i];
+        ripplesArray[i] = ripples[i];
     }
     for (int i = rippleCount; i < MAX_SHADER_RIPPLES; ++i) {
-        m_pipelineWaterRipples[pipelineId][i] = {0.0f, 0.0f, 0.0f};
+        ripplesArray[i] = {0.0f, 0.0f, 0.0f};
     }
+    m_pipelineWaterRipples.insert(pipelineId, ripplesArray);
 
-    auto infoIt = m_pipelineInfo.find(pipelineId);
-    if (infoIt != m_pipelineInfo.end()) {
-        infoIt->second.isWaterPipeline = true;
+    PipelineInfo** infoPtrPtr = m_pipelineInfo.find(pipelineId);
+    if (infoPtrPtr != nullptr) {
+        (*infoPtrPtr)->isWaterPipeline = true;
     }
 }
 
 void VulkanPipeline::getWaterRipples(int pipelineId, int& outRippleCount, ShaderRippleData* outRipples) const {
-    auto countIt = m_pipelineWaterRippleCount.find(pipelineId);
-    if (countIt == m_pipelineWaterRippleCount.end()) {
+    const int* countPtr = m_pipelineWaterRippleCount.find(pipelineId);
+    if (countPtr == nullptr) {
         outRippleCount = 0;
         return;
     }
-    outRippleCount = countIt->second;
-    auto rippleIt = m_pipelineWaterRipples.find(pipelineId);
-    if (rippleIt != m_pipelineWaterRipples.end()) {
+    outRippleCount = *countPtr;
+    const std::array<ShaderRippleData, MAX_SHADER_RIPPLES>* ripplesPtr = m_pipelineWaterRipples.find(pipelineId);
+    if (ripplesPtr != nullptr) {
         for (int i = 0; i < outRippleCount; ++i) {
-            outRipples[i] = rippleIt->second[i];
+            outRipples[i] = (*ripplesPtr)[i];
         }
     }
 }
 
 void VulkanPipeline::setPipelineParallaxDepth(int pipelineId, float depth) {
-    m_pipelineParallaxDepth[pipelineId] = depth;
+    m_pipelineParallaxDepth.insert(pipelineId, depth);
 }
 
 float VulkanPipeline::getPipelineParallaxDepth(int pipelineId) const {
-    auto it = m_pipelineParallaxDepth.find(pipelineId);
-    if (it != m_pipelineParallaxDepth.end()) {
-        return it->second;
+    const float* depthPtr = m_pipelineParallaxDepth.find(pipelineId);
+    if (depthPtr != nullptr) {
+        return *depthPtr;
     }
     return 0.0f;
 }
 
 void VulkanPipeline::setCurrentPipeline(uint64_t id) {
-    auto it = m_pipelines.find(id);
-    assert(it != m_pipelines.end());
-    m_currentPipeline = it->second;
+    const VkPipeline* pipelinePtr = m_pipelines.find(id);
+    assert(pipelinePtr != nullptr);
+    m_currentPipeline = *pipelinePtr;
 }
 
 void VulkanPipeline::destroyPipeline(uint64_t id) {
-    auto it = m_pipelines.find(id);
-    if (it != m_pipelines.end()) {
-        vkDestroyPipeline(m_device, it->second, nullptr);
-        m_pipelines.erase(it);
+    VkPipeline* pipelinePtr = m_pipelines.find(id);
+    if (pipelinePtr != nullptr) {
+        vkDestroyPipeline(m_device, *pipelinePtr, nullptr);
+        m_pipelines.remove(id);
+    }
+    m_debugPipelines.remove(id);
+    
+    // Delete the dynamically allocated PipelineInfo
+    PipelineInfo** infoPtrPtr = m_pipelineInfo.find(id);
+    if (infoPtrPtr != nullptr) {
+        PipelineInfo* info = *infoPtrPtr;
+        info->~PipelineInfo();
+        m_allocator->free(info);
+        m_pipelineInfo.remove(id);
     }
-    m_debugPipelines.erase(id);
-    m_pipelineInfo.erase(id);
 }
 
 void VulkanPipeline::setShaders(const ResourceData& vertShader, const ResourceData& fragShader) {
diff --git a/src/vulkan/VulkanPipeline.h b/src/vulkan/VulkanPipeline.h
index f086d15..3073bfc 100644
--- a/src/vulkan/VulkanPipeline.h
+++ b/src/vulkan/VulkanPipeline.h
@@ -3,7 +3,7 @@
 #include <vulkan/vulkan.h>
 #include "../resources/resource.h"
 #include "../core/Vector.h"
-#include <map>
+#include "../core/HashTable.h"
 #include <set>
 #include <array>
 #include <cstdint>
@@ -114,24 +114,24 @@ private:
     VkPipelineLayout m_pipelineLayout;
 
     // Pipelines
-    std::map<uint64_t, VkPipeline> m_pipelines;
-    std::map<uint64_t, bool> m_debugPipelines;
+    HashTable<uint64_t, VkPipeline> m_pipelines;
+    HashTable<uint64_t, bool> m_debugPipelines;
     VkPipeline m_debugLinePipeline;
     VkPipeline m_debugTrianglePipeline;
     VkPipeline m_currentPipeline;
     Vector<uint64_t> m_pipelinesToDraw;
 
     // Pipeline info
-    std::map<uint64_t, PipelineInfo> m_pipelineInfo;
+    HashTable<uint64_t, PipelineInfo*> m_pipelineInfo;
 
     // Per-pipeline shader parameters
-    std::map<int, std::array<float, 7>> m_pipelineShaderParams;
-    std::map<int, int> m_pipelineShaderParamCount;
-    std::map<int, float> m_pipelineParallaxDepth;
+    HashTable<int, std::array<float, 7>> m_pipelineShaderParams;
+    HashTable<int, int> m_pipelineShaderParamCount;
+    HashTable<int, float> m_pipelineParallaxDepth;
 
     // Per-pipeline water ripple data
-    std::map<int, std::array<ShaderRippleData, MAX_SHADER_RIPPLES>> m_pipelineWaterRipples;
-    std::map<int, int> m_pipelineWaterRippleCount;
+    HashTable<int, std::array<ShaderRippleData, MAX_SHADER_RIPPLES>> m_pipelineWaterRipples;
+    HashTable<int, int> m_pipelineWaterRippleCount;
 
     // Shader data storage
     Vector<char> m_vertShaderData;
diff --git a/src/vulkan/VulkanRenderer.cpp b/src/vulkan/VulkanRenderer.cpp
index e7fdabe..50b10a1 100644
--- a/src/vulkan/VulkanRenderer.cpp
+++ b/src/vulkan/VulkanRenderer.cpp
@@ -57,7 +57,10 @@ inline uint32_t clamp(uint32_t value, uint32_t min, uint32_t max) {
 }
 
 VulkanRenderer::VulkanRenderer(MemoryAllocator* allocator) :
+    m_textureManager(allocator),
+    m_descriptorManager(allocator),
     m_pipelineManager(allocator),
+    m_lightManager(allocator),
     m_instance(VK_NULL_HANDLE),
     m_surface(VK_NULL_HANDLE),
     m_physicalDevice(VK_NULL_HANDLE),
@@ -1402,12 +1405,15 @@ void VulkanRenderer::recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t
                 const auto& singleTexDescSets = m_descriptorManager.getSingleTextureDescriptorSets();
                 if (!singleTexDescSets.empty()) {
                     VkDescriptorSet descriptorSet = VK_NULL_HANDLE;
-                    auto it = singleTexDescSets.find(batch.textureId);
-                    if (it != singleTexDescSets.end()) {
-                        descriptorSet = it->second;
+                    const VkDescriptorSet* descSetPtr = singleTexDescSets.find(batch.textureId);
+                    if (descSetPtr != nullptr) {
+                        descriptorSet = *descSetPtr;
                     }
                     if (descriptorSet == VK_NULL_HANDLE) {
-                        descriptorSet = singleTexDescSets.begin()->second;
+                        auto it = singleTexDescSets.begin();
+                        if (it != singleTexDescSets.end()) {
+                            descriptorSet = it.value();
+                        }
                     }
                     vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                                           info->layout, 0, 1, &descriptorSet, 0, nullptr);
diff --git a/src/vulkan/VulkanTexture.cpp b/src/vulkan/VulkanTexture.cpp
index c5ead35..61e5dbe 100644
--- a/src/vulkan/VulkanTexture.cpp
+++ b/src/vulkan/VulkanTexture.cpp
@@ -5,13 +5,16 @@
 #include <iostream>
 #include <set>
 
-VulkanTexture::VulkanTexture() :
+VulkanTexture::VulkanTexture(MemoryAllocator* allocator) :
     m_device(VK_NULL_HANDLE),
     m_physicalDevice(VK_NULL_HANDLE),
     m_commandPool(VK_NULL_HANDLE),
     m_graphicsQueue(VK_NULL_HANDLE),
-    m_initialized(false)
+    m_initialized(false),
+    m_textures(*allocator, "VulkanTexture::m_textures"),
+    m_allocator(allocator)
 {
+    assert(m_allocator != nullptr);
 }
 
 VulkanTexture::~VulkanTexture() {
@@ -203,12 +206,12 @@ void VulkanTexture::createTextureImage(uint64_t textureId, const void* imageData
     assert(vkCreateImageView(m_device, &viewInfo, nullptr, &tex.imageView) == VK_SUCCESS);
 
     tex.sampler = VK_NULL_HANDLE; // Will be created by createTextureSampler
-    m_textures[textureId] = tex;
+    m_textures.insert(textureId, tex);
 }
 
 void VulkanTexture::createTextureSampler(uint64_t textureId) {
-    auto it = m_textures.find(textureId);
-    assert(it != m_textures.end());
+    TextureData* texPtr = m_textures.find(textureId);
+    assert(texPtr != nullptr);
 
     VkSamplerCreateInfo samplerInfo{};
     samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
@@ -228,37 +231,37 @@ void VulkanTexture::createTextureSampler(uint64_t textureId) {
     samplerInfo.minLod = 0.0f;
     samplerInfo.maxLod = 0.0f;
 
-    assert(vkCreateSampler(m_device, &samplerInfo, nullptr, &it->second.sampler) == VK_SUCCESS);
+    assert(vkCreateSampler(m_device, &samplerInfo, nullptr, &texPtr->sampler) == VK_SUCCESS);
 }
 
 bool VulkanTexture::getTexture(uint64_t textureId, TextureData* outData) const {
-    auto it = m_textures.find(textureId);
-    if (it == m_textures.end()) {
+    const TextureData* texPtr = m_textures.find(textureId);
+    if (texPtr == nullptr) {
         return false;
     }
     if (outData) {
-        *outData = it->second;
+        *outData = *texPtr;
     }
     return true;
 }
 
 bool VulkanTexture::hasTexture(uint64_t textureId) const {
-    return m_textures.find(textureId) != m_textures.end();
+    return m_textures.find(textureId) != nullptr;
 }
 
 bool VulkanTexture::getTextureDimensions(uint64_t textureId, uint32_t* width, uint32_t* height) const {
-    auto it = m_textures.find(textureId);
-    if (it == m_textures.end()) {
+    const TextureData* texPtr = m_textures.find(textureId);
+    if (texPtr == nullptr) {
         return false;
     }
-    if (width) *width = it->second.width;
-    if (height) *height = it->second.height;
+    if (width) *width = texPtr->width;
+    if (height) *height = texPtr->height;
     return true;
 }
 
 void VulkanTexture::loadTexture(uint64_t textureId, const ResourceData& imageData) {
     // If texture already exists, skip reloading (textures don't change during hot-reload)
-    if (m_textures.find(textureId) != m_textures.end()) {
+    if (m_textures.find(textureId) != nullptr) {
         std::cout << "Texture " << textureId << ": already in GPU memory (cache hit)" << std::endl;
         return;
     }
@@ -275,14 +278,15 @@ void VulkanTexture::loadTexture(uint64_t textureId, const ResourceData& imageDat
         uint64_t atlasId = texHeader->atlasId;
         std::cout << "Texture " << textureId << ": atlas reference (atlas id: " << atlasId << ", UV: " << texHeader->coordinates[0] << "," << texHeader->coordinates[1] << " - " << texHeader->coordinates[4] << "," << texHeader->coordinates[5] << ")" << std::endl;
         // Load the atlas if not already loaded
-        if (m_textures.find(atlasId) == m_textures.end()) {
+        const TextureData* atlasTexPtr = m_textures.find(atlasId);
+        if (atlasTexPtr == nullptr) {
             // Atlas not loaded, but we can't load it here without data
             std::cerr << "Atlas " << atlasId << " not loaded for texture " << textureId << std::endl;
             assert(false && "Atlas texture not loaded");
             return;
         }
         // Associate the texture ID with the atlas texture
-        m_textures[textureId] = m_textures[atlasId];
+        m_textures.insert(textureId, *atlasTexPtr);
         createTextureSampler(textureId);
         return;
     } else {
@@ -320,7 +324,7 @@ void VulkanTexture::loadTexture(uint64_t textureId, const ResourceData& imageDat
 
 void VulkanTexture::loadAtlasTexture(uint64_t atlasId, const ResourceData& atlasData) {
     // If atlas texture already exists, skip reloading
-    if (m_textures.find(atlasId) != m_textures.end()) {
+    if (m_textures.find(atlasId) != nullptr) {
         std::cout << "Atlas " << atlasId << ": already in GPU memory (cache hit)" << std::endl;
         return;
     }
@@ -359,25 +363,25 @@ void VulkanTexture::loadAtlasTexture(uint64_t atlasId, const ResourceData& atlas
 }
 
 void VulkanTexture::destroyTexture(uint64_t textureId) {
-    auto it = m_textures.find(textureId);
-    if (it == m_textures.end()) {
+    TextureData* texPtr = m_textures.find(textureId);
+    if (texPtr == nullptr) {
         return;
     }
 
-    if (it->second.sampler != VK_NULL_HANDLE) {
-        vkDestroySampler(m_device, it->second.sampler, nullptr);
+    if (texPtr->sampler != VK_NULL_HANDLE) {
+        vkDestroySampler(m_device, texPtr->sampler, nullptr);
     }
-    if (it->second.imageView != VK_NULL_HANDLE) {
-        vkDestroyImageView(m_device, it->second.imageView, nullptr);
+    if (texPtr->imageView != VK_NULL_HANDLE) {
+        vkDestroyImageView(m_device, texPtr->imageView, nullptr);
     }
-    if (it->second.image != VK_NULL_HANDLE) {
-        vkDestroyImage(m_device, it->second.image, nullptr);
+    if (texPtr->image != VK_NULL_HANDLE) {
+        vkDestroyImage(m_device, texPtr->image, nullptr);
     }
-    if (it->second.memory != VK_NULL_HANDLE) {
-        vkFreeMemory(m_device, it->second.memory, nullptr);
+    if (texPtr->memory != VK_NULL_HANDLE) {
+        vkFreeMemory(m_device, texPtr->memory, nullptr);
     }
 
-    m_textures.erase(it);
+    m_textures.remove(textureId);
 }
 
 void VulkanTexture::destroyAllTextures() {
@@ -386,22 +390,22 @@ void VulkanTexture::destroyAllTextures() {
     std::set<VkImage> destroyedImages;
     std::set<VkDeviceMemory> destroyedMemories;
 
-    for (auto& pair : m_textures) {
-        if (pair.second.sampler != VK_NULL_HANDLE && destroyedSamplers.find(pair.second.sampler) == destroyedSamplers.end()) {
-            vkDestroySampler(m_device, pair.second.sampler, nullptr);
-            destroyedSamplers.insert(pair.second.sampler);
+    for (auto it = m_textures.begin(); it != m_textures.end(); ++it) {
+        if (it.value().sampler != VK_NULL_HANDLE && destroyedSamplers.find(it.value().sampler) == destroyedSamplers.end()) {
+            vkDestroySampler(m_device, it.value().sampler, nullptr);
+            destroyedSamplers.insert(it.value().sampler);
         }
-        if (pair.second.imageView != VK_NULL_HANDLE && destroyedImageViews.find(pair.second.imageView) == destroyedImageViews.end()) {
-            vkDestroyImageView(m_device, pair.second.imageView, nullptr);
-            destroyedImageViews.insert(pair.second.imageView);
+        if (it.value().imageView != VK_NULL_HANDLE && destroyedImageViews.find(it.value().imageView) == destroyedImageViews.end()) {
+            vkDestroyImageView(m_device, it.value().imageView, nullptr);
+            destroyedImageViews.insert(it.value().imageView);
         }
-        if (pair.second.image != VK_NULL_HANDLE && destroyedImages.find(pair.second.image) == destroyedImages.end()) {
-            vkDestroyImage(m_device, pair.second.image, nullptr);
-            destroyedImages.insert(pair.second.image);
+        if (it.value().image != VK_NULL_HANDLE && destroyedImages.find(it.value().image) == destroyedImages.end()) {
+            vkDestroyImage(m_device, it.value().image, nullptr);
+            destroyedImages.insert(it.value().image);
         }
-        if (pair.second.memory != VK_NULL_HANDLE && destroyedMemories.find(pair.second.memory) == destroyedMemories.end()) {
-            vkFreeMemory(m_device, pair.second.memory, nullptr);
-            destroyedMemories.insert(pair.second.memory);
+        if (it.value().memory != VK_NULL_HANDLE && destroyedMemories.find(it.value().memory) == destroyedMemories.end()) {
+            vkFreeMemory(m_device, it.value().memory, nullptr);
+            destroyedMemories.insert(it.value().memory);
         }
     }
     m_textures.clear();
@@ -409,7 +413,7 @@ void VulkanTexture::destroyAllTextures() {
 
 void VulkanTexture::createRenderTargetTexture(uint64_t textureId, uint32_t width, uint32_t height, VkFormat format) {
     // Destroy existing texture if present
-    if (m_textures.find(textureId) != m_textures.end()) {
+    if (m_textures.find(textureId) != nullptr) {
         destroyTexture(textureId);
     }
 
@@ -533,7 +537,7 @@ void VulkanTexture::createRenderTargetTexture(uint64_t textureId, uint32_t width
 
     assert(vkCreateSampler(m_device, &samplerInfo, nullptr, &tex.sampler) == VK_SUCCESS);
 
-    m_textures[textureId] = tex;
+    m_textures.insert(textureId, tex);
 
     std::cout << "Created render target texture " << textureId << " (" << width << "x" << height << ")" << std::endl;
 }
diff --git a/src/vulkan/VulkanTexture.h b/src/vulkan/VulkanTexture.h
index e7e32f7..871c9f9 100644
--- a/src/vulkan/VulkanTexture.h
+++ b/src/vulkan/VulkanTexture.h
@@ -2,13 +2,14 @@
 
 #include <vulkan/vulkan.h>
 #include "../resources/resource.h"
-#include <map>
+#include "../core/HashTable.h"
+#include "../memory/MemoryAllocator.h"
 #include <cstdint>
 
 // Helper class for managing Vulkan textures
 class VulkanTexture {
 public:
-    VulkanTexture();
+    VulkanTexture(MemoryAllocator* allocator);
     ~VulkanTexture();
 
     // Initialization - must be called before any other operations
@@ -46,7 +47,7 @@ public:
     void destroyAllTextures();
 
     // Access textures map directly for iteration
-    const std::map<uint64_t, TextureData>& getTextures() const { return m_textures; }
+    const HashTable<uint64_t, TextureData>& getTextures() const { return m_textures; }
 
 private:
     uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
@@ -57,5 +58,6 @@ private:
     VkQueue m_graphicsQueue;
     bool m_initialized;
 
-    std::map<uint64_t, TextureData> m_textures;
+    HashTable<uint64_t, TextureData> m_textures;
+    MemoryAllocator* m_allocator;
 };
